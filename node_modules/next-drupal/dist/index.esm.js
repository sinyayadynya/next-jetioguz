import NodeCache from 'node-cache';
import Jsona from 'jsona';
import { stringify } from 'qs';
import * as React from 'react';
import { useRouter } from 'next/router';

var cache = new NodeCache();

var getAccessToken = function getAccessToken() {
  try {
    if (!process.env.DRUPAL_CLIENT_ID || !process.env.DRUPAL_CLIENT_SECRET) {
      return Promise.resolve(null);
    }

    var cached = cache.get(CACHE_KEY);

    if (cached != null && cached.access_token) {
      return Promise.resolve(cached);
    }

    var basic = Buffer.from(process.env.DRUPAL_CLIENT_ID + ":" + process.env.DRUPAL_CLIENT_SECRET).toString("base64");
    return Promise.resolve(fetch(process.env.NEXT_PUBLIC_DRUPAL_BASE_URL + "/oauth/token", {
      method: "POST",
      headers: {
        Authorization: "Basic " + basic,
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: "grant_type=client_credentials"
    })).then(function (response) {
      if (!response.ok) {
        throw new Error(response.statusText);
      }

      return Promise.resolve(response.json()).then(function (result) {
        cache.set(CACHE_KEY, result, result.expires_in);
        return result;
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var CACHE_KEY = "NEXT_DRUPAL_ACCESS_TOKEN";

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var buildHeaders = function buildHeaders(_temp4) {
  var _ref = _temp4 === void 0 ? {} : _temp4,
      accessToken = _ref.accessToken,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {
    "Content-Type": "application/json"
  } : _ref$headers;

  try {
    var _temp5 = function _temp5(token) {
      if (token) {
        headers["Authorization"] = "Bearer " + token.access_token;
      }

      return headers;
    };

    // This allows an access_token (preferrably long-lived) to be set directly on the env.
    // This reduces the number of OAuth call to the Drupal server.
    // Intentionally marked as unstable for now.
    if (process.env.UNSTABLE_DRUPAL_ACCESS_TOKEN) {
      headers["Authorization"] = "Bearer " + process.env.UNSTABLE_DRUPAL_ACCESS_TOKEN;
      return Promise.resolve(headers);
    }

    return Promise.resolve(accessToken ? _temp5(accessToken) : Promise.resolve(getAccessToken()).then(_temp5));
  } catch (e) {
    return Promise.reject(e);
  }
};
var getJsonApiIndex = function getJsonApiIndex(locale, options) {
  try {
    var _temp2 = function _temp2(_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        headers: _buildHeaders
      })).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json());
      });
    };

    var url = buildUrl(locale ? "/" + locale + JSONAPI_PREFIX : "" + JSONAPI_PREFIX); // As per https://www.drupal.org/node/2984034 /jsonapi is public.
    // We only call buildHeaders if accessToken or locale is explicitly set.
    // This is for rare cases where /jsonapi might be protected.

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(locale || options ? Promise.resolve(locale || options ? buildHeaders(options) : {
      "Content-Type": "application/json"
    }).then(_temp2) : _temp2(locale || options ? buildHeaders(options) : {
      "Content-Type": "application/json"
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var getJsonApiPathForResourceType = function getJsonApiPathForResourceType(type, locale) {
  return Promise.resolve(getJsonApiIndex(locale)).then(function (index) {
    var _index$links$type;

    return index == null ? void 0 : (_index$links$type = index.links[type]) == null ? void 0 : _index$links$type.href;
  });
};
var JSONAPI_PREFIX = process.env.DRUPAL_JSONAPI_PREFIX || "/jsonapi";
var dataFormatter = new Jsona();
function deserialize(body, options) {
  if (!body) return null;
  return dataFormatter.deserialize(body, options);
}
function buildUrl(path, params) {
  var url = new URL(path.charAt(0) === "/" ? "" + process.env.NEXT_PUBLIC_DRUPAL_BASE_URL + path : path);

  if (params) {
    // Use instead URLSearchParams for nested params.
    url.search = stringify(params);
  }

  return url;
}
function getPathFromContext(context, prefix) {
  if (prefix === void 0) {
    prefix = "";
  }

  var slug = context.params.slug;
  slug = Array.isArray(slug) ? slug.map(function (s) {
    return encodeURIComponent(s);
  }).join("/") : slug; // Handle locale.

  if (context.locale && context.locale !== context.defaultLocale) {
    slug = "/" + context.locale + "/" + slug;
  }

  return !slug ? process.env.DRUPAL_FRONT_PAGE : prefix ? prefix + "/" + slug : slug;
}
function syncDrupalPreviewRoutes(path) {
  if (window && window.top !== window.self) {
    window.parent.postMessage({
      type: "NEXT_DRUPAL_ROUTE_SYNC",
      path: path
    }, process.env.NEXT_PUBLIC_DRUPAL_BASE_URL);
  }
}

var getMenu = function getMenu(name, options) {
  try {
    var _options;

    options = _extends({
      deserialize: true
    }, options);
    var localePrefix = (_options = options) != null && _options.locale && options.locale !== options.defaultLocale ? "/" + options.locale : "";
    var url = buildUrl(localePrefix + "/jsonapi/menu_items/" + name);

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        headers: _buildHeaders
      })).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json()).then(function (data) {
          var items = options.deserialize ? deserialize(data) : data;

          var _buildMenuTree = buildMenuTree(items),
              tree = _buildMenuTree.items;

          return {
            items: items,
            tree: tree
          };
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function buildMenuTree(links, parent) {
  if (parent === void 0) {
    parent = "";
  }

  if (!(links != null && links.length)) {
    return {
      items: []
    };
  }

  var children = links.filter(function (link) {
    return link.parent === parent;
  });
  return children.length ? {
    items: children.map(function (link) {
      return _extends({}, link, buildMenuTree(links, link.id));
    })
  } : {};
}

var getResourceCollectionFromContext = function getResourceCollectionFromContext(type, context, options) {
  try {
    options = _extends({
      deserialize: true
    }, options); // // Filter out unpublished entities.
    // if (!context.preview) {
    //   options.params = {
    //     "filter[status]": "1",
    //     ...options.params,
    //   }
    // }

    return Promise.resolve(getResourceCollection(type, _extends({}, options, {
      locale: context.locale,
      defaultLocale: context.defaultLocale
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};
var getResourceCollection = function getResourceCollection(type, options) {
  try {
    var _options, _options2;

    options = _extends({
      deserialize: true
    }, options);
    return Promise.resolve(getJsonApiPathForResourceType(type, ((_options = options) == null ? void 0 : _options.locale) !== ((_options2 = options) == null ? void 0 : _options2.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
      var _options3;

      if (!apiPath) {
        throw new Error("Error: resource of type " + type + " not found.");
      }

      var url = buildUrl(apiPath, _extends({}, (_options3 = options) == null ? void 0 : _options3.params));

      var _fetch = fetch,
          _url$toString = url.toString();

      return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
        return Promise.resolve(_fetch(_url$toString, {
          headers: _buildHeaders
        })).then(function (response) {
          if (!response.ok) {
            throw new Error(response.statusText);
          }

          return Promise.resolve(response.json()).then(function (json) {
            return options.deserialize ? deserialize(json) : json;
          });
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var getPathsFromContext = function getPathsFromContext(types, context, options) {
  if (options === void 0) {
    options = {};
  }

  try {
    if (typeof types === "string") {
      types = [types];
    }

    return Promise.resolve(Promise.all(types.map(function (type) {
      try {
        var _extends2, _options;

        var _temp3 = function _temp3(_result) {
          return _exit2 ? _result : Promise.resolve(Promise.all(context.locales.map(function (locale) {
            try {
              return Promise.resolve(getResourceCollection(type, _extends({
                deserialize: true,
                locale: locale,
                defaultLocale: context.defaultLocale
              }, options))).then(function (resources) {
                return buildPathsFromResources(resources, locale);
              });
            } catch (e) {
              return Promise.reject(e);
            }
          }))).then(function (paths) {
            return paths.flat();
          });
        };

        var _exit2;

        // Use sparse fieldset to expand max size.
        options.params = _extends((_extends2 = {}, _extends2["fields[" + type + "]"] = "path", _extends2), (_options = options) == null ? void 0 : _options.params); // const paths = await Promise.all(
        //   context.locales.map(async (locale) => {
        //     const resources = await getResourceCollection(type, {
        //       deserialize: true,
        //       locale,
        //       defaultLocale: context.defaultLocale,
        //       ...options,
        //     })
        //     return buildPathsFromResources(resources, locale)
        //   })
        // )
        // return paths.flat()
        // Handle localized path aliases

        var _temp4 = function () {
          var _context$locales;

          if (!((_context$locales = context.locales) != null && _context$locales.length)) {
            return Promise.resolve(getResourceCollection(type, _extends({
              deserialize: true
            }, options))).then(function (resources) {
              var _buildPathsFromResour = buildPathsFromResources(resources);

              _exit2 = 1;
              return _buildPathsFromResour;
            });
          }
        }();

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    }))).then(function (paths) {
      return paths.flat();
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function buildPathsFromResources(resources, locale) {
  return resources == null ? void 0 : resources.flatMap(function (resource) {
    var _resource$path, _resource$path2;

    var slug = (resource == null ? void 0 : (_resource$path = resource.path) == null ? void 0 : _resource$path.alias) === process.env.DRUPAL_FRONT_PAGE ? "/" : resource == null ? void 0 : (_resource$path2 = resource.path) == null ? void 0 : _resource$path2.alias;
    var path = {
      params: {
        slug: ("" + (slug == null ? void 0 : slug.replace(/^\/|\/$/g, ""))).split("/")
      }
    };

    if (locale) {
      path["locale"] = locale;
    }

    return path;
  });
}

var _excluded$1 = ["resourceVersion"];
var getResource = function getResource(type, uuid, options) {
  try {
    var _options3, _options4;

    options = _extends({
      deserialize: true,
      params: {}
    }, options);
    return Promise.resolve(getJsonApiPathForResourceType(type, ((_options3 = options) == null ? void 0 : _options3.locale) !== ((_options4 = options) == null ? void 0 : _options4.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
      var _options5;

      if (!apiPath) {
        throw new Error("Error: resource of type " + type + " not found.");
      }

      var url = buildUrl(apiPath + "/" + uuid, _extends({}, (_options5 = options) == null ? void 0 : _options5.params));

      var _fetch3 = fetch,
          _url$toString3 = url.toString();

      return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders2) {
        return Promise.resolve(_fetch3(_url$toString3, {
          headers: _buildHeaders2
        })).then(function (response) {
          if (!response.ok) {
            throw new Error(response.statusText);
          }

          return Promise.resolve(response.json()).then(function (json) {
            return options.deserialize ? deserialize(json) : json;
          });
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var getResourceByPath = function getResourceByPath(path, options) {
  try {
    options = _extends({
      deserialize: true,
      isVersionable: false,
      params: {}
    }, options);

    if (!path) {
      return Promise.resolve(null);
    }

    if (options.locale && options.defaultLocale && path.indexOf(options.locale) !== 1) {
      path = path === "/" ? path : path.replace(/^\/+/, "");
      path = getPathFromContext({
        params: {
          slug: [path]
        },
        locale: options.locale,
        defaultLocale: options.defaultLocale
      });
    }

    var _options$params = options.params,
        _options$params$resou = _options$params.resourceVersion,
        resourceVersion = _options$params$resou === void 0 ? "rel:latest-version" : _options$params$resou,
        params = _objectWithoutPropertiesLoose(_options$params, _excluded$1);

    if (options.isVersionable) {
      params.resourceVersion = resourceVersion;
    }

    var resourceParams = stringify(params);
    var payload = [{
      requestId: "router",
      action: "view",
      uri: "/router/translate-path?path=" + path + "&_format=json",
      headers: {
        Accept: "application/vnd.api+json"
      }
    }, {
      requestId: "resolvedResource",
      action: "view",
      uri: "{{router.body@$.jsonapi.individual}}?" + resourceParams.toString(),
      waitFor: ["router"]
    }]; // Localized subrequests.
    // I was hoping we would not need this but it seems like subrequests is not properly
    // setting the jsonapi locale from a translated path.

    var subrequestsPath = "/subrequests";

    if (options.locale && options.defaultLocale && options.locale !== options.defaultLocale) {
      subrequestsPath = "/" + options.locale + "/subrequests";
    }

    var url = buildUrl(subrequestsPath, {
      _format: "json"
    });

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        method: "POST",
        credentials: "include",
        headers: _buildHeaders,
        redirect: "follow",
        body: JSON.stringify(payload)
      })).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json()).then(function (json) {
          var _json$resolvedResourc;

          if (!json["resolvedResource#uri{0}"]) {
            return null;
          }

          var data = JSON.parse((_json$resolvedResourc = json["resolvedResource#uri{0}"]) == null ? void 0 : _json$resolvedResourc.body);

          if (data.errors) {
            throw new Error(data.errors[0].detail);
          }

          return options.deserialize ? deserialize(data) : data;
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var getResourceFromContext = function getResourceFromContext(type, context, options) {
  try {
    var _options, _options2;

    options = _extends({
      deserialize: true,
      // Add support for revisions for node by default.
      // TODO: Make this required before stable?
      isVersionable: /^node--/.test(type)
    }, options);
    var path = getPathFromContext(context, (_options = options) == null ? void 0 : _options.prefix); // Filter out unpublished entities.
    // if (!context.preview) {
    //   options.params = {
    //     "filter[status]": "1",
    //     ...options?.params,
    //   }
    // }

    var previewData = context.previewData;
    return Promise.resolve(getResourceByPath(path, {
      deserialize: options.deserialize,
      isVersionable: options.isVersionable,
      locale: context.locale,
      defaultLocale: context.defaultLocale,
      params: _extends({
        resourceVersion: previewData == null ? void 0 : previewData.resourceVersion
      }, (_options2 = options) == null ? void 0 : _options2.params)
    })); // If no locale is passed, skip entity if not default_langcode.
    // This happens because decoupled_router will still translate the path
    // to a resource.
    // TODO: Figure out if we want this behavior.
    // For now this causes a bug where a non-i18n sites builds (ISR) pages for
    // localized pages.
    // if (!context.locale && !resource?.default_langcode) {
    //   return null
    // }
  } catch (e) {
    return Promise.reject(e);
  }
};

var getResourcePreviewUrl = function getResourcePreviewUrl(slug, options) {
  try {
    return Promise.resolve(getResourceByPath(slug, options)).then(function (entity) {
      if (!entity) {
        return null;
      }

      if (!(entity != null && entity.path)) {
        throw new Error("Error: the path attribute is missing for entity type " + entity.type);
      }

      return entity != null && entity.default_langcode ? entity.path.alias : "/" + entity.path.langcode + entity.path.alias;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var PreviewHandler = function PreviewHandler(request, response, options) {
  try {
    var _request$query = request.query,
        slug = _request$query.slug,
        resourceVersion = _request$query.resourceVersion,
        secret = _request$query.secret,
        locale = _request$query.locale,
        defaultLocale = _request$query.defaultLocale;

    if (secret !== process.env.DRUPAL_PREVIEW_SECRET) {
      return Promise.resolve(response.status(401).json({
        message: (options == null ? void 0 : options.errorMessages.secret) || "Invalid preview secret."
      }));
    }

    if (!slug) {
      return Promise.resolve(response.status(401).end({
        message: (options == null ? void 0 : options.errorMessages.slug) || "Invalid slug."
      }));
    }

    var _options = {
      isVersionable: typeof resourceVersion !== "undefined"
    };

    if (locale && defaultLocale) {
      _options = _extends({}, _options, {
        locale: locale,
        defaultLocale: defaultLocale
      });
    }

    return Promise.resolve(getResourcePreviewUrl(slug, _options)).then(function (url) {
      if (!url) {
        response.status(404).end({
          message: (options == null ? void 0 : options.errorMessages.slug) || "Invalid slug"
        });
      }

      response.setPreviewData({
        resourceVersion: resourceVersion
      });
      response.writeHead(307, {
        Location: url
      });
      return response.end();
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
function DrupalPreview(options) {
  return function (request, response) {
    return PreviewHandler(request, response, options);
  };
}

var translatePathFromContext = function translatePathFromContext(context, options) {
  try {
    options = _extends({
      prefix: ""
    }, options);
    var path = getPathFromContext(context, options.prefix);
    return Promise.resolve(translatePath(path, {
      accessToken: options.accessToken
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var translatePath = function translatePath(path, options) {
  try {
    var url = buildUrl("/router/translate-path", {
      path: path
    });

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        headers: _buildHeaders
      })).then(function (response) {
        return response.ok ? Promise.resolve(response.json()) : null;
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function _catch$2(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var getResourceTypeFromContext = function getResourceTypeFromContext(context, options) {
  return Promise.resolve(_catch$2(function () {
    return Promise.resolve(translatePathFromContext(context, options)).then(function (response) {
      return response.jsonapi.resourceName;
    });
  }, function () {
    return null;
  }));
};

var getSearchIndexFromContext = function getSearchIndexFromContext(name, context, options) {
  try {
    options = _extends({
      deserialize: true
    }, options);
    return Promise.resolve(getSearchIndex(name, _extends({}, options, {
      locale: context.locale,
      defaultLocale: context.defaultLocale
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};
var getSearchIndex = function getSearchIndex(name, options) {
  try {
    var _options;

    options = _extends({
      deserialize: true
    }, options);
    var localePrefix = (_options = options) != null && _options.locale && options.locale !== options.defaultLocale ? "/" + options.locale : "";
    var url = buildUrl(localePrefix + "/jsonapi/index/" + name, options.params);

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        headers: _buildHeaders
      })).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json()).then(function (json) {
          return options.deserialize ? deserialize(json) : json;
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var getView = function getView(name, options) {
  try {
    var _options;

    options = _extends({
      deserialize: true
    }, options);
    var localePrefix = (_options = options) != null && _options.locale && options.locale !== options.defaultLocale ? "/" + options.locale : "";

    var _name$split = name.split("--"),
        viewId = _name$split[0],
        displayId = _name$split[1];

    var url = buildUrl(localePrefix + "/jsonapi/views/" + viewId + "/" + displayId, options.params);

    var _fetch2 = fetch,
        _url$toString2 = url.toString();

    return Promise.resolve(buildHeaders(options)).then(function (_buildHeaders) {
      return Promise.resolve(_fetch2(_url$toString2, {
        headers: _buildHeaders
      })).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return Promise.resolve(response.json()).then(function (data) {
          var results = options.deserialize ? deserialize(data) : data;
          return {
            results: results,
            meta: data.meta,
            links: data.links
          };
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function _catch$1(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function useMenu(name) {
  var router = useRouter();

  var _React$useState = React.useState(null),
      data = _React$useState[0],
      setData = _React$useState[1];

  var _React$useState2 = React.useState(null),
      error = _React$useState2[0],
      setError = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      isLoading = _React$useState3[0],
      setIsLoading = _React$useState3[1];

  React.useEffect(function () {
    var fetchMenuItems = function fetchMenuItems() {
      try {
        setIsLoading(true);

        var _temp2 = _catch$1(function () {
          return Promise.resolve(getMenu(name, {
            locale: router.locale,
            defaultLocale: router.defaultLocale
          })).then(function (data) {
            setData(data);
            setIsLoading(false);
          });
        }, function (error) {
          setError(error);
          setIsLoading(false);
        });

        return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    };

    fetchMenuItems();
  }, [router.locale]);
  return _extends({}, data, {
    error: error,
    isLoading: isLoading
  });
}

// Default logger. Uses console.
var logger = {
  log: function log(message) {
    console.log("[next-drupal][log]:", message);
  },
  debug: function debug(message) {
    console.debug("[next-drupal][debug]:", message);
  },
  warn: function warn(message) {
    console.warn("[next-drupal][debug]:", message);
  },
  error: function error(message) {
    console.error("[next-drupal][error]:", message);
  }
};

var JsonApiErrors = /*#__PURE__*/function (_Error) {
  _inheritsLoose(JsonApiErrors, _Error);

  function JsonApiErrors(errors, statusCode) {
    var _this;

    _this = _Error.call(this) || this;
    _this.errors = void 0;
    _this.statusCode = void 0;
    _this.errors = errors;
    _this.statusCode = statusCode;
    _this.message = JsonApiErrors.formatMessage(errors);
    return _this;
  }

  JsonApiErrors.formatMessage = function formatMessage(errors) {
    if (typeof errors === "string") {
      return errors;
    }

    var error = errors[0];
    var message = error.status + " " + error.title;

    if (error.detail) {
      message += "\n" + error.detail;
    }

    return message;
  };

  return JsonApiErrors;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _excluded = ["resourceVersion"];

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}
var DEFAULT_API_PREFIX = "/jsonapi";
var DEFAULT_FRONT_PAGE = "/home";
var DEFAULT_WITH_AUTH = false; // From simple_oauth.

var DEFAULT_AUTH_URL = "/oauth/token"; // See https://jsonapi.org/format/#content-negotiation.

var DEFAULT_HEADERS = {
  "Content-Type": "application/vnd.api+json",
  Accept: "application/vnd.api+json"
};

function isBasicAuth(auth) {
  return (auth == null ? void 0 : auth.username) !== undefined || (auth == null ? void 0 : auth.password) !== undefined;
}

function isAccessTokenAuth(auth) {
  return (auth == null ? void 0 : auth.access_token) !== undefined;
}

function isClientIdSecretAuth(auth) {
  return (auth == null ? void 0 : auth.clientId) !== undefined || (auth == null ? void 0 : auth.clientSecret) !== undefined;
}

var DrupalClient = /*#__PURE__*/function () {
  /**
   * Instantiates a new DrupalClient.
   *
   * const client = new DrupalClient(baseUrl)
   *
   * @param {baseUrl} baseUrl The baseUrl of your Drupal site. Do not add the /jsonapi suffix.
   * @param {options} options Options for the client. See Experiment_DrupalClientOptions.
   */
  function DrupalClient(baseUrl, options) {
    if (options === void 0) {
      options = {};
    }

    this.baseUrl = void 0;
    this.debug = void 0;
    this.frontPage = void 0;
    this.serializer = void 0;
    this.cache = void 0;
    this.throwJsonApiErrors = void 0;
    this.logger = void 0;
    this.fetcher = void 0;
    this._headers = void 0;
    this._auth = void 0;
    this._apiPrefix = void 0;
    this.useDefaultResourceTypeEntry = void 0;
    this._token = void 0;
    this.accessToken = void 0;
    this.accessTokenScope = void 0;
    this.tokenExpiresOn = void 0;
    this.withAuth = void 0;
    this.previewSecret = void 0;
    this.forceIframeSameSiteCookie = void 0;
    this.getPathsFromContext = this.getStaticPathsFromContext;

    if (!baseUrl || typeof baseUrl !== "string") {
      throw new Error("The 'baseUrl' param is required.");
    }

    var _options2 = options,
        _options2$apiPrefix = _options2.apiPrefix,
        apiPrefix = _options2$apiPrefix === void 0 ? DEFAULT_API_PREFIX : _options2$apiPrefix,
        _options2$serializer = _options2.serializer,
        serializer = _options2$serializer === void 0 ? new Jsona() : _options2$serializer,
        _options2$cache = _options2.cache,
        cache = _options2$cache === void 0 ? null : _options2$cache,
        _options2$debug = _options2.debug,
        debug = _options2$debug === void 0 ? false : _options2$debug,
        _options2$frontPage = _options2.frontPage,
        frontPage = _options2$frontPage === void 0 ? DEFAULT_FRONT_PAGE : _options2$frontPage,
        _options2$useDefaultR = _options2.useDefaultResourceTypeEntry,
        useDefaultResourceTypeEntry = _options2$useDefaultR === void 0 ? false : _options2$useDefaultR,
        _options2$headers = _options2.headers,
        headers = _options2$headers === void 0 ? DEFAULT_HEADERS : _options2$headers,
        _options2$logger = _options2.logger,
        logger$1 = _options2$logger === void 0 ? logger : _options2$logger,
        _options2$withAuth = _options2.withAuth,
        withAuth = _options2$withAuth === void 0 ? DEFAULT_WITH_AUTH : _options2$withAuth,
        fetcher = _options2.fetcher,
        auth = _options2.auth,
        previewSecret = _options2.previewSecret,
        accessToken = _options2.accessToken,
        _options2$forceIframe = _options2.forceIframeSameSiteCookie,
        forceIframeSameSiteCookie = _options2$forceIframe === void 0 ? false : _options2$forceIframe,
        _options2$throwJsonAp = _options2.throwJsonApiErrors,
        throwJsonApiErrors = _options2$throwJsonAp === void 0 ? true : _options2$throwJsonAp;
    this.baseUrl = baseUrl;
    this.apiPrefix = apiPrefix;
    this.serializer = serializer;
    this.frontPage = frontPage;
    this.debug = debug;
    this.useDefaultResourceTypeEntry = useDefaultResourceTypeEntry;
    this.fetcher = fetcher;
    this.auth = auth;
    this.headers = headers;
    this.logger = logger$1;
    this.withAuth = withAuth;
    this.previewSecret = previewSecret;
    this.cache = cache;
    this.accessToken = accessToken;
    this.forceIframeSameSiteCookie = forceIframeSameSiteCookie;
    this.throwJsonApiErrors = throwJsonApiErrors; // Do not throw errors in production.

    if (process.env.NODE_ENV === "production") {
      this.throwJsonApiErrors = false;
    }

    this._debug("Debug mode is on.");
  }

  var _proto = DrupalClient.prototype;

  /* eslint-disable @typescript-eslint/no-explicit-any */
  _proto.fetch = function (_fetch) {
    function fetch(_x, _x2) {
      return _fetch.apply(this, arguments);
    }

    fetch.toString = function () {
      return _fetch.toString();
    };

    return fetch;
  }(function (input, init) {
    try {
      var _init;

      var _temp14 = function _temp14(_result2) {
        var _exit2;

        if (_exit3) return _result2;

        function _temp11(_result3) {
          if (_exit2) return _result3;

          _this2._debug("Using default fetch (polyfilled by Next.js).");

          return Promise.resolve(fetch(input, init));
        }

        var _temp10 = function () {
          if (_this2.fetcher) {
            _this2._debug("Using custom fetcher.");

            return Promise.resolve(_this2.fetcher(input, init)).then(function (_await$_this$fetcher) {
              _exit2 = 1;
              return _await$_this$fetcher;
            });
          }
        }();

        return _temp10 && _temp10.then ? _temp10.then(_temp11) : _temp11(_temp10);
      };

      var _exit3;

      var _this2 = this;

      init = _extends({}, init, {
        credentials: "include",
        headers: _extends({}, _this2._headers, (_init = init) == null ? void 0 : _init.headers)
      }); // Using the auth set on the client.
      // TODO: Abstract this to a re-usable.

      var _temp15 = function () {
        var _init2;

        if ((_init2 = init) != null && _init2.withAuth) {
          _this2._debug("Using authenticated request.");

          return function () {
            if (init.withAuth === true) {
              if (typeof _this2._auth === "undefined") {
                throw new Error("auth is not configured. See https://next-drupal.org/docs/client/auth");
              } // By default, if withAuth is set to true, we use the auth configured
              // in the client constructor.


              var _temp16 = function () {
                if (typeof _this2._auth === "function") {
                  _this2._debug("Using custom auth callback.");

                  init["headers"]["Authorization"] = _this2._auth();
                } else {
                  var _temp17 = function () {
                    if (typeof _this2._auth === "string") {
                      _this2._debug("Using custom authorization header.");

                      init["headers"]["Authorization"] = _this2._auth;
                    } else {
                      var _temp18 = function () {
                        if (typeof _this2._auth === "object") {
                          _this2._debug("Using custom auth credentials.");

                          var _temp19 = function () {
                            if (isBasicAuth(_this2._auth)) {
                              var basic = Buffer.from(_this2._auth.username + ":" + _this2._auth.password).toString("base64");
                              init["headers"]["Authorization"] = "Basic " + basic;
                            } else {
                              var _temp20 = function () {
                                if (isClientIdSecretAuth(_this2._auth)) {
                                  // Use the built-in client_credentials grant.
                                  _this2._debug("Using default auth (client_credentials)."); // Fetch an access token and add it to the request.
                                  // Access token can be fetched from cache or using a custom auth method.


                                  return Promise.resolve(_this2.getAccessToken(_this2._auth)).then(function (token) {
                                    if (token) {
                                      init["headers"]["Authorization"] = "Bearer " + token.access_token;
                                    }
                                  });
                                } else if (isAccessTokenAuth(_this2._auth)) {
                                  init["headers"]["Authorization"] = _this2._auth.token_type + " " + _this2._auth.access_token;
                                }
                              }();

                              if (_temp20 && _temp20.then) return _temp20.then(function () {});
                            }
                          }();

                          if (_temp19 && _temp19.then) return _temp19.then(function () {});
                        }
                      }();

                      if (_temp18 && _temp18.then) return _temp18.then(function () {});
                    }
                  }();

                  if (_temp17 && _temp17.then) return _temp17.then(function () {});
                }
              }();

              if (_temp16 && _temp16.then) return _temp16.then(function () {});
            } else {
              var _temp21 = function () {
                if (typeof init.withAuth === "string") {
                  _this2._debug("Using custom authorization header.");

                  init["headers"]["Authorization"] = init.withAuth;
                } else {
                  var _temp22 = function () {
                    if (typeof init.withAuth === "function") {
                      _this2._debug("Using custom authorization callback.");

                      init["headers"]["Authorization"] = init.withAuth();
                    } else {
                      var _temp23 = function () {
                        if (isBasicAuth(init.withAuth)) {
                          _this2._debug("Using basic authorization header");

                          var basic = Buffer.from(init.withAuth.username + ":" + init.withAuth.password).toString("base64");
                          init["headers"]["Authorization"] = "Basic " + basic;
                        } else {
                          var _temp24 = function () {
                            if (isClientIdSecretAuth(init.withAuth)) {
                              // Fetch an access token and add it to the request.
                              // Access token can be fetched from cache or using a custom auth method.
                              return Promise.resolve(_this2.getAccessToken(init.withAuth)).then(function (token) {
                                if (token) {
                                  init["headers"]["Authorization"] = "Bearer " + token.access_token;
                                }
                              });
                            } else if (isAccessTokenAuth(init.withAuth)) {
                              init["headers"]["Authorization"] = init.withAuth.token_type + " " + init.withAuth.access_token;
                            }
                          }();

                          if (_temp24 && _temp24.then) return _temp24.then(function () {});
                        }
                      }();

                      if (_temp23 && _temp23.then) return _temp23.then(function () {});
                    }
                  }();

                  if (_temp22 && _temp22.then) return _temp22.then(function () {});
                }
              }();

              if (_temp21 && _temp21.then) return _temp21.then(function () {});
            }
          }();
        }
      }();

      return Promise.resolve(_temp15 && _temp15.then ? _temp15.then(_temp14) : _temp14(_temp15));
    } catch (e) {
      return Promise.reject(e);
    }
  });

  _proto.createResource = function createResource(type, body, options) {
    try {
      var _options3, _options4;

      var _this4 = this;

      options = _extends({
        deserialize: true,
        withAuth: true
      }, options);
      return Promise.resolve(_this4.getEntryForResourceType(type, ((_options3 = options) == null ? void 0 : _options3.locale) !== ((_options4 = options) == null ? void 0 : _options4.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
        var _options5;

        var url = _this4.buildUrl(apiPath, (_options5 = options) == null ? void 0 : _options5.params);

        _this4._debug("Creating resource of type " + type + ".");

        _this4._debug(url.toString()); // Add type to body.


        body.data.type = type;
        return Promise.resolve(_this4.fetch(url.toString(), {
          method: "POST",
          body: JSON.stringify(body),
          withAuth: options.withAuth
        })).then(function (response) {
          function _temp26() {
            return Promise.resolve(response.json()).then(function (json) {
              return options.deserialize ? _this4.deserialize(json) : json;
            });
          }

          var _temp25 = function () {
            if (!(response != null && response.ok)) {
              return Promise.resolve(_this4.handleJsonApiErrors(response)).then(function () {});
            }
          }();

          return _temp25 && _temp25.then ? _temp25.then(_temp26) : _temp26(_temp25);
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.createFileResource = function createFileResource(type, body, options) {
    try {
      var _body$data, _body$data$attributes, _options6, _options7;

      var _this6 = this;

      options = _extends({
        deserialize: true,
        withAuth: true
      }, options);
      var hostType = body == null ? void 0 : (_body$data = body.data) == null ? void 0 : (_body$data$attributes = _body$data.attributes) == null ? void 0 : _body$data$attributes.type;
      return Promise.resolve(_this6.getEntryForResourceType(hostType, ((_options6 = options) == null ? void 0 : _options6.locale) !== ((_options7 = options) == null ? void 0 : _options7.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
        var _options8;

        var url = _this6.buildUrl(apiPath + "/" + body.data.attributes.field, (_options8 = options) == null ? void 0 : _options8.params);

        _this6._debug("Creating file resource for media of type " + type + ".");

        _this6._debug(url.toString());

        return Promise.resolve(_this6.fetch(url.toString(), {
          method: "POST",
          headers: {
            "Content-Type": "application/octet-stream",
            Accept: "application/vnd.api+json",
            "Content-Disposition": "file; filename=\"" + body.data.attributes.filename + "\""
          },
          body: body.data.attributes.file,
          withAuth: options.withAuth
        })).then(function (response) {
          function _temp28() {
            return Promise.resolve(response.json()).then(function (json) {
              return options.deserialize ? _this6.deserialize(json) : json;
            });
          }

          var _temp27 = function () {
            if (!(response != null && response.ok)) {
              return Promise.resolve(_this6.handleJsonApiErrors(response)).then(function () {});
            }
          }();

          return _temp27 && _temp27.then ? _temp27.then(_temp28) : _temp28(_temp27);
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.updateResource = function updateResource(type, uuid, body, options) {
    try {
      var _options9, _options10;

      var _this8 = this;

      options = _extends({
        deserialize: true,
        withAuth: true
      }, options);
      return Promise.resolve(_this8.getEntryForResourceType(type, ((_options9 = options) == null ? void 0 : _options9.locale) !== ((_options10 = options) == null ? void 0 : _options10.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
        var _options11;

        var url = _this8.buildUrl(apiPath + "/" + uuid, (_options11 = options) == null ? void 0 : _options11.params);

        _this8._debug("Updating resource of type " + type + " with id " + uuid + ".");

        _this8._debug(url.toString()); // Update body.


        body.data.type = type;
        body.data.id = uuid;
        return Promise.resolve(_this8.fetch(url.toString(), {
          method: "PATCH",
          body: JSON.stringify(body),
          withAuth: options.withAuth
        })).then(function (response) {
          function _temp30() {
            return Promise.resolve(response.json()).then(function (json) {
              return options.deserialize ? _this8.deserialize(json) : json;
            });
          }

          var _temp29 = function () {
            if (!(response != null && response.ok)) {
              return Promise.resolve(_this8.handleJsonApiErrors(response)).then(function () {});
            }
          }();

          return _temp29 && _temp29.then ? _temp29.then(_temp30) : _temp30(_temp29);
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.deleteResource = function deleteResource(type, uuid, options) {
    try {
      var _options12, _options13;

      var _this10 = this;

      options = _extends({
        withAuth: true,
        params: {}
      }, options);
      return Promise.resolve(_this10.getEntryForResourceType(type, ((_options12 = options) == null ? void 0 : _options12.locale) !== ((_options13 = options) == null ? void 0 : _options13.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
        var _options14;

        var url = _this10.buildUrl(apiPath + "/" + uuid, (_options14 = options) == null ? void 0 : _options14.params);

        _this10._debug("Deleting resource of type " + type + " with id " + uuid + ".");

        _this10._debug(url.toString());

        return Promise.resolve(_this10.fetch(url.toString(), {
          method: "DELETE",
          withAuth: options.withAuth
        })).then(function (response) {
          function _temp32() {
            return response.status === 204;
          }

          var _temp31 = function () {
            if (!(response != null && response.ok)) {
              return Promise.resolve(_this10.handleJsonApiErrors(response)).then(function () {});
            }
          }();

          return _temp31 && _temp31.then ? _temp31.then(_temp32) : _temp32(_temp31);
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getResource = function getResource(type, uuid, options) {
    try {
      var _temp40 = function _temp40(_result4) {
        var _options15, _options16;

        return _exit5 ? _result4 : Promise.resolve(_this12.getEntryForResourceType(type, ((_options15 = options) == null ? void 0 : _options15.locale) !== ((_options16 = options) == null ? void 0 : _options16.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
          var _options17;

          var url = _this12.buildUrl(apiPath + "/" + uuid, (_options17 = options) == null ? void 0 : _options17.params);

          _this12._debug("Fetching resource " + type + " with id " + uuid + ".");

          _this12._debug(url.toString());

          return Promise.resolve(_this12.fetch(url.toString(), {
            withAuth: options.withAuth
          })).then(function (response) {
            function _temp37() {
              return Promise.resolve(response.json()).then(function (json) {
                function _temp35() {
                  return options.deserialize ? _this12.deserialize(json) : json;
                }

                var _temp34 = function () {
                  if (options.withCache) {
                    return Promise.resolve(_this12.cache.set(options.cacheKey, JSON.stringify(json))).then(function () {});
                  }
                }();

                return _temp34 && _temp34.then ? _temp34.then(_temp35) : _temp35(_temp34);
              });
            }

            var _temp36 = function () {
              if (!(response != null && response.ok)) {
                return Promise.resolve(_this12.handleJsonApiErrors(response)).then(function () {});
              }
            }();

            return _temp36 && _temp36.then ? _temp36.then(_temp37) : _temp37(_temp36);
          });
        });
      };

      var _exit5;

      var _this12 = this;

      options = _extends({
        deserialize: true,
        withAuth: _this12.withAuth,
        withCache: false,
        params: {}
      }, options);

      var _temp41 = function () {
        if (options.withCache) {
          return Promise.resolve(_this12.cache.get(options.cacheKey)).then(function (cached) {
            if (cached) {
              _this12._debug("Returning cached resource " + type + " with id " + uuid);

              var json = JSON.parse(cached);

              var _temp42 = options.deserialize ? _this12.deserialize(json) : json;

              _exit5 = 1;
              return _temp42;
            }
          });
        }
      }();

      return Promise.resolve(_temp41 && _temp41.then ? _temp41.then(_temp40) : _temp40(_temp41));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getResourceFromContext = function getResourceFromContext(input, context, options) {
    try {
      var _options19, _options20;

      var _temp45 = function _temp45(_result6) {
        var _options18;

        if (_exit7) return _result6;

        var path = _this14.getPathFromContext(context, {
          pathPrefix: (_options18 = options) == null ? void 0 : _options18.pathPrefix
        });

        return Promise.resolve(_this14.getResourceByPath(path, _options)); // If no locale is passed, skip entity if not default_langcode.
        // This happens because decoupled_router will still translate the path
        // to a resource.
        // TODO: Figure out if we want this behavior.
        // For now this causes a bug where a non-i18n sites builds (ISR) pages for
        // localized pages.
        // if (!context.locale && !resource?.default_langcode) {
        //   return null
        // }
      };

      var _exit7;

      var _this14 = this;

      var type = typeof input === "string" ? input : input.jsonapi.resourceName;
      var previewData = context.previewData;
      options = _extends({
        deserialize: true,
        pathPrefix: "/",
        withAuth: _this14.getAuthFromContextAndOptions(context, options),
        params: {}
      }, options);
      var _options = {
        deserialize: options.deserialize,
        isVersionable: options.isVersionable,
        locale: context.locale,
        defaultLocale: context.defaultLocale,
        withAuth: (_options19 = options) == null ? void 0 : _options19.withAuth,
        params: (_options20 = options) == null ? void 0 : _options20.params
      }; // Check if resource is versionable.
      // Add support for revisions for node by default.

      var isVersionable = options.isVersionable || /^node--/.test(type); // If the resource is versionable and no resourceVersion is supplied via params.
      // Use the resourceVersion from previewData or fallback to the latest version.

      if (isVersionable && typeof options.params.resourceVersion === "undefined") {
        options.params.resourceVersion = (previewData == null ? void 0 : previewData.resourceVersion) || "rel:latest-version";
      }

      var _temp46 = function () {
        if (typeof input !== "string") {
          // Fix for subrequests and translation.
          // TODO: Confirm if we still need this after https://www.drupal.org/i/3111456.
          // @shadcn, note to self:
          // Given an entity at /example with no translation.
          // When we try to translate /es/example, decoupled router will properly
          // translate to the untranslated version and set the locale to es.
          // However a subrequests to /es/subrequests for decoupled router will fail.
          if (context.locale && input.entity.langcode !== context.locale) {
            context.locale = input.entity.langcode;
          } // Given we already have the path info, we can skip subrequests and just make a simple
          // request to the Drupal site to get the entity.


          return function () {
            var _input$entity;

            if ((_input$entity = input.entity) != null && _input$entity.uuid) {
              return Promise.resolve(_this14.getResource(type, input.entity.uuid, _options)).then(function (_await$_this13$getRes) {
                _exit7 = 1;
                return _await$_this13$getRes;
              });
            }
          }();
        }
      }();

      return Promise.resolve(_temp46 && _temp46.then ? _temp46.then(_temp45) : _temp45(_temp46));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getResourceByPath = function getResourceByPath(path, options) {
    try {
      var _this16 = this;

      options = _extends({
        deserialize: true,
        isVersionable: false,
        withAuth: _this16.withAuth,
        params: {}
      }, options);

      if (!path) {
        return Promise.resolve(null);
      }

      if (options.locale && options.defaultLocale && path.indexOf(options.locale) !== 1) {
        path = path === "/" ? path : path.replace(/^\/+/, "");
        path = _this16.getPathFromContext({
          params: {
            slug: [path]
          },
          locale: options.locale,
          defaultLocale: options.defaultLocale
        });
      } // If a resourceVersion is provided, assume entity type is versionable.


      if (options.params.resourceVersion) {
        options.isVersionable = true;
      }

      var _options$params = options.params,
          _options$params$resou = _options$params.resourceVersion,
          resourceVersion = _options$params$resou === void 0 ? "rel:latest-version" : _options$params$resou,
          params = _objectWithoutPropertiesLoose(_options$params, _excluded);

      if (options.isVersionable) {
        params.resourceVersion = resourceVersion;
      }

      var resourceParams = stringify(params); // We are intentionally not using translatePath here.
      // We want a single request using subrequests.

      var payload = [{
        requestId: "router",
        action: "view",
        uri: "/router/translate-path?path=" + path + "&_format=json",
        headers: {
          Accept: "application/vnd.api+json"
        }
      }, {
        requestId: "resolvedResource",
        action: "view",
        uri: "{{router.body@$.jsonapi.individual}}?" + resourceParams.toString(),
        waitFor: ["router"]
      }]; // Localized subrequests.
      // I was hoping we would not need this but it seems like subrequests is not properly
      // setting the jsonapi locale from a translated path.
      // TODO: Confirm if we still need this after https://www.drupal.org/i/3111456.

      var subrequestsPath = "/subrequests";

      if (options.locale && options.defaultLocale && options.locale !== options.defaultLocale) {
        subrequestsPath = "/" + options.locale + "/subrequests";
      }

      var url = _this16.buildUrl(subrequestsPath, {
        _format: "json"
      });

      return Promise.resolve(_this16.fetch(url.toString(), {
        method: "POST",
        credentials: "include",
        redirect: "follow",
        body: JSON.stringify(payload),
        withAuth: options.withAuth
      })).then(function (response) {
        return Promise.resolve(response.json()).then(function (json) {
          var _json$resolvedResourc, _json$resolvedResourc2;

          if (!(json != null && (_json$resolvedResourc = json["resolvedResource#uri{0}"]) != null && _json$resolvedResourc.body)) {
            var _json$router;

            if (json != null && (_json$router = json.router) != null && _json$router.body) {
              var error = JSON.parse(json.router.body);

              if (error != null && error.message) {
                _this16.throwError(new Error(error.message));
              }
            }

            return null;
          }

          var data = JSON.parse((_json$resolvedResourc2 = json["resolvedResource#uri{0}"]) == null ? void 0 : _json$resolvedResourc2.body);

          if (data.errors) {
            _this16.throwError(new Error(_this16.formatJsonApiErrors(data.errors)));
          }

          return options.deserialize ? _this16.deserialize(data) : data;
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getResourceCollection = function getResourceCollection(type, options) {
    try {
      var _options21, _options22;

      var _this18 = this;

      options = _extends({
        withAuth: _this18.withAuth,
        deserialize: true
      }, options);
      return Promise.resolve(_this18.getEntryForResourceType(type, ((_options21 = options) == null ? void 0 : _options21.locale) !== ((_options22 = options) == null ? void 0 : _options22.defaultLocale) ? options.locale : undefined)).then(function (apiPath) {
        var _options23;

        var url = _this18.buildUrl(apiPath, _extends({}, (_options23 = options) == null ? void 0 : _options23.params));

        _this18._debug("Fetching resource collection of type " + type);

        _this18._debug(url.toString());

        return Promise.resolve(_this18.fetch(url.toString(), {
          withAuth: options.withAuth
        })).then(function (response) {
          function _temp48() {
            return Promise.resolve(response.json()).then(function (json) {
              return options.deserialize ? _this18.deserialize(json) : json;
            });
          }

          var _temp47 = function () {
            if (!(response != null && response.ok)) {
              return Promise.resolve(_this18.handleJsonApiErrors(response)).then(function () {});
            }
          }();

          return _temp47 && _temp47.then ? _temp47.then(_temp48) : _temp48(_temp47);
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getResourceCollectionFromContext = function getResourceCollectionFromContext(type, context, options) {
    try {
      var _this20 = this;

      options = _extends({
        deserialize: true
      }, options);
      return Promise.resolve(_this20.getResourceCollection(type, _extends({}, options, {
        locale: context.locale,
        defaultLocale: context.defaultLocale,
        withAuth: _this20.getAuthFromContextAndOptions(context, options)
      })));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getStaticPathsFromContext = function getStaticPathsFromContext(types, context, options) {
    try {
      var _this22 = this;

      options = _extends({
        withAuth: _this22.withAuth,
        pathPrefix: "/",
        params: {}
      }, options);

      if (typeof types === "string") {
        types = [types];
      }

      return Promise.resolve(Promise.all(types.map(function (type) {
        try {
          var _extends2, _options24;

          var _temp51 = function _temp51(_result7) {
            return _exit9 ? _result7 : Promise.resolve(Promise.all(context.locales.map(function (locale) {
              try {
                return Promise.resolve(_this22.getResourceCollection(type, {
                  deserialize: true,
                  locale: locale,
                  defaultLocale: context.defaultLocale,
                  params: params,
                  withAuth: options.withAuth
                })).then(function (resources) {
                  return _this22.buildStaticPathsFromResources(resources, {
                    locale: locale,
                    pathPrefix: options.pathPrefix
                  });
                });
              } catch (e) {
                return Promise.reject(e);
              }
            }))).then(function (paths) {
              return paths.flat();
            });
          };

          var _exit9;

          // Use sparse fieldset to expand max size.
          // Note we don't need status filter here since this runs non-authenticated (by default).
          var params = _extends((_extends2 = {}, _extends2["fields[" + type + "]"] = "path", _extends2), (_options24 = options) == null ? void 0 : _options24.params); // Handle localized path aliases


          var _temp52 = function () {
            var _context$locales;

            if (!((_context$locales = context.locales) != null && _context$locales.length)) {
              return Promise.resolve(_this22.getResourceCollection(type, {
                params: params,
                withAuth: options.withAuth
              })).then(function (resources) {
                var _this22$buildStaticPa = _this22.buildStaticPathsFromResources(resources, {
                  pathPrefix: options.pathPrefix
                });

                _exit9 = 1;
                return _this22$buildStaticPa;
              });
            }
          }();

          return Promise.resolve(_temp52 && _temp52.then ? _temp52.then(_temp51) : _temp51(_temp52));
        } catch (e) {
          return Promise.reject(e);
        }
      }))).then(function (paths) {
        return paths.flat();
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.buildStaticPathsFromResources = function buildStaticPathsFromResources(resources, options) {
    var _this23 = this;

    var paths = resources == null ? void 0 : resources.flatMap(function (resource) {
      var _resource$path, _resource$path2;

      return (resource == null ? void 0 : (_resource$path = resource.path) == null ? void 0 : _resource$path.alias) === _this23.frontPage ? "/" : resource == null ? void 0 : (_resource$path2 = resource.path) == null ? void 0 : _resource$path2.alias;
    }).filter(Boolean);
    return paths != null && paths.length ? this.buildStaticPathsParamsFromPaths(paths, options) : [];
  };

  _proto.buildStaticPathsParamsFromPaths = function buildStaticPathsParamsFromPaths(paths, options) {
    return paths.flatMap(function (_path) {
      _path = _path.replace(/^\/|\/$/g, ""); // Remove pathPrefix.

      if (options != null && options.pathPrefix && options.pathPrefix !== "/") {
        // Remove leading slash from pathPrefix.
        var pathPrefix = options.pathPrefix.replace(/^\//, "");
        _path = _path.replace(pathPrefix + "/", "");
      }

      var path = {
        params: {
          slug: _path.split("/")
        }
      };

      if (options != null && options.locale) {
        path["locale"] = options.locale;
      }

      return path;
    });
  };

  _proto.translatePath = function translatePath(path, options) {
    try {
      var _this25 = this;

      options = _extends({
        withAuth: _this25.withAuth
      }, options);

      var url = _this25.buildUrl("/router/translate-path", {
        path: path
      });

      return Promise.resolve(_this25.fetch(url.toString(), {
        withAuth: options.withAuth
      })).then(function (response) {
        return response != null && response.ok ? Promise.resolve(response.json()) : null;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.translatePathFromContext = function translatePathFromContext(context, options) {
    try {
      var _this27 = this;

      options = _extends({
        pathPrefix: "/"
      }, options);

      var path = _this27.getPathFromContext(context, {
        pathPrefix: options.pathPrefix
      });

      return Promise.resolve(_this27.translatePath(path, {
        withAuth: _this27.getAuthFromContextAndOptions(context, options)
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getPathFromContext = function getPathFromContext(context, options) {
    var _context$params, _options$pathPrefix;

    options = _extends({
      pathPrefix: "/"
    }, options);
    var slug = (_context$params = context.params) == null ? void 0 : _context$params.slug;
    var pathPrefix = ((_options$pathPrefix = options.pathPrefix) == null ? void 0 : _options$pathPrefix.charAt(0)) === "/" ? options.pathPrefix : "/" + options.pathPrefix; // Handle locale.

    if (context.locale && context.locale !== context.defaultLocale) {
      pathPrefix = "/" + context.locale + pathPrefix;
    }

    slug = Array.isArray(slug) ? slug.map(function (s) {
      return encodeURIComponent(s);
    }).join("/") : slug; // Handle front page.

    if (!slug) {
      slug = this.frontPage;
      pathPrefix = pathPrefix.replace(/\/$/, "");
    }

    slug = pathPrefix.slice(-1) !== "/" && slug.charAt(0) !== "/" ? "/" + slug : slug;
    return "" + pathPrefix + slug;
  };

  _proto.getIndex = function getIndex(locale) {
    try {
      var _this29 = this;

      var url = _this29.buildUrl(locale ? "/" + locale + _this29.apiPrefix : _this29.apiPrefix);

      return Promise.resolve(_catch(function () {
        return Promise.resolve(_this29.fetch(url.toString(), {
          // As per https://www.drupal.org/node/2984034 /jsonapi is public.
          withAuth: false
        })).then(function (response) {
          return Promise.resolve(response.json());
        });
      }, function (error) {
        _this29.throwError(new Error("Failed to fetch JSON:API index at " + url.toString() + " - " + error.message));
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getEntryForResourceType = function getEntryForResourceType(type, locale) {
    try {
      var _this31 = this;

      if (_this31.useDefaultResourceTypeEntry) {
        var _type$split = type.split("--"),
            id = _type$split[0],
            bundle = _type$split[1];

        return Promise.resolve("" + _this31.baseUrl + (locale ? "/" + locale + _this31.apiPrefix + "/" : _this31.apiPrefix + "/") + (id + "/" + bundle));
      }

      return Promise.resolve(_this31.getIndex(locale)).then(function (index) {
        var _index$links;

        var link = (_index$links = index.links) == null ? void 0 : _index$links[type];

        if (!link) {
          throw new Error("Resource of type '" + type + "' not found.");
        }

        var href = link.href; // Fix for missing locale in JSON:API index.
        // This fix ensures the locale is included in the resouce link.

        if (locale) {
          var pattern = "^\\/" + locale + "\\/";
          var path = href.replace(_this31.baseUrl, "");

          if (!new RegExp(pattern, "i").test(path)) {
            return _this31.baseUrl + "/" + locale + path;
          }
        }

        return href;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.preview = function preview(request, response, options) {
    try {
      var _this33 = this;

      var _request$query = request.query,
          slug = _request$query.slug,
          resourceVersion = _request$query.resourceVersion,
          plugin = _request$query.plugin;
      return Promise.resolve(_catch(function () {
        // Always clear preview data to handle different scopes.
        response.clearPreviewData(); // Validate the preview url.

        var validateUrl = _this33.buildUrl("/next/preview-url");

        return Promise.resolve(_this33.fetch(validateUrl.toString(), {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(request.query)
        })).then(function (result) {
          var _exit10;

          function _temp54(_result9) {
            return _exit10 ? _result9 : Promise.resolve(result.json()).then(function (validationPayload) {
              response.setPreviewData(_extends({
                resourceVersion: resourceVersion,
                plugin: plugin
              }, validationPayload)); // Fix issue with cookie.
              // See https://github.com/vercel/next.js/discussions/32238.
              // See https://github.com/vercel/next.js/blob/d895a50abbc8f91726daa2d7ebc22c58f58aabbb/packages/next/server/api-utils/node.ts#L504.

              if (_this33.forceIframeSameSiteCookie) {
                var previous = response.getHeader("Set-Cookie");
                previous.forEach(function (cookie, index) {
                  previous[index] = cookie.replace("SameSite=Lax", "SameSite=None;Secure");
                });
                response.setHeader("Set-Cookie", previous);
              } // We can safely redirect to the slug since this has been validated on the server.


              response.writeHead(307, {
                Location: slug
              });
              return response.end();
            });
          }

          var _temp53 = function () {
            if (!result.ok) {
              response.statusCode = result.status;
              var _json2 = response.json;
              return Promise.resolve(result.json()).then(function (_result$json) {
                var _response$json2 = _json2.call(response, _result$json);

                _exit10 = 1;
                return _response$json2;
              });
            }
          }();

          return _temp53 && _temp53.then ? _temp53.then(_temp54) : _temp54(_temp53);
        });
      }, function () {
        return response.status(422).end();
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getMenu = function getMenu(name, options) {
    try {
      var _temp60 = function _temp60(_result10) {
        var _options25;

        if (_exit12) return _result10;
        var localePrefix = (_options25 = options) != null && _options25.locale && options.locale !== options.defaultLocale ? "/" + options.locale : "";

        var url = _this35.buildUrl("" + localePrefix + _this35.apiPrefix + "/menu_items/" + name, options.params);

        _this35._debug("Fetching menu items for " + name + ".");

        _this35._debug(url.toString());

        return Promise.resolve(_this35.fetch(url.toString(), {
          withAuth: options.withAuth
        })).then(function (response) {
          function _temp57() {
            return Promise.resolve(response.json()).then(function (data) {
              var items = options.deserialize ? _this35.deserialize(data) : data;

              var _this34$buildMenuTree = _this35.buildMenuTree(items),
                  tree = _this34$buildMenuTree.items;

              var menu = {
                items: items,
                tree: tree
              };

              var _temp55 = function () {
                if (options.withCache) {
                  return Promise.resolve(_this35.cache.set(options.cacheKey, JSON.stringify(menu))).then(function () {});
                }
              }();

              return _temp55 && _temp55.then ? _temp55.then(function () {
                return menu;
              }) : menu;
            });
          }

          var _temp56 = function () {
            if (!(response != null && response.ok)) {
              return Promise.resolve(_this35.handleJsonApiErrors(response)).then(function () {});
            }
          }();

          return _temp56 && _temp56.then ? _temp56.then(_temp57) : _temp57(_temp56);
        });
      };

      var _exit12;

      var _this35 = this;

      options = _extends({
        withAuth: _this35.withAuth,
        deserialize: true,
        params: {},
        withCache: false
      }, options);

      var _temp61 = function () {
        if (options.withCache) {
          return Promise.resolve(_this35.cache.get(options.cacheKey)).then(function (cached) {
            if (cached) {
              _this35._debug("Returning cached menu items for " + name);

              var _JSON$parse2 = JSON.parse(cached);

              _exit12 = 1;
              return _JSON$parse2;
            }
          });
        }
      }();

      return Promise.resolve(_temp61 && _temp61.then ? _temp61.then(_temp60) : _temp60(_temp61));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.buildMenuTree = function buildMenuTree(links, parent) {
    var _this36 = this;

    if (parent === void 0) {
      parent = "";
    }

    if (!(links != null && links.length)) {
      return {
        items: []
      };
    }

    var children = links.filter(function (link) {
      return (link == null ? void 0 : link.parent) === parent;
    });
    return children.length ? {
      items: children.map(function (link) {
        return _extends({}, link, _this36.buildMenuTree(links, link.id));
      })
    } : {};
  };

  _proto.getView = function getView(name, options) {
    try {
      var _options26;

      var _this38 = this;

      options = _extends({
        withAuth: _this38.withAuth,
        deserialize: true,
        params: {}
      }, options);
      var localePrefix = (_options26 = options) != null && _options26.locale && options.locale !== options.defaultLocale ? "/" + options.locale : "";

      var _name$split = name.split("--"),
          viewId = _name$split[0],
          displayId = _name$split[1];

      var url = _this38.buildUrl("" + localePrefix + _this38.apiPrefix + "/views/" + viewId + "/" + displayId, options.params);

      return Promise.resolve(_this38.fetch(url.toString(), {
        withAuth: options.withAuth
      })).then(function (response) {
        function _temp63() {
          return Promise.resolve(response.json()).then(function (data) {
            var results = options.deserialize ? _this38.deserialize(data) : data;
            return {
              id: name,
              results: results,
              meta: data.meta,
              links: data.links
            };
          });
        }

        var _temp62 = function () {
          if (!(response != null && response.ok)) {
            return Promise.resolve(_this38.handleJsonApiErrors(response)).then(function () {});
          }
        }();

        return _temp62 && _temp62.then ? _temp62.then(_temp63) : _temp63(_temp62);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getSearchIndex = function getSearchIndex(name, options) {
    try {
      var _options27;

      var _this40 = this;

      options = _extends({
        withAuth: _this40.withAuth,
        deserialize: true
      }, options);
      var localePrefix = (_options27 = options) != null && _options27.locale && options.locale !== options.defaultLocale ? "/" + options.locale : "";

      var url = _this40.buildUrl("" + localePrefix + _this40.apiPrefix + "/index/" + name, options.params);

      return Promise.resolve(_this40.fetch(url.toString(), {
        withAuth: options.withAuth
      })).then(function (response) {
        function _temp65() {
          return Promise.resolve(response.json()).then(function (json) {
            return options.deserialize ? _this40.deserialize(json) : json;
          });
        }

        var _temp64 = function () {
          if (!(response != null && response.ok)) {
            return Promise.resolve(_this40.handleJsonApiErrors(response)).then(function () {});
          }
        }();

        return _temp64 && _temp64.then ? _temp64.then(_temp65) : _temp65(_temp64);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getSearchIndexFromContext = function getSearchIndexFromContext(name, context, options) {
    try {
      var _this42 = this;

      return Promise.resolve(_this42.getSearchIndex(name, _extends({}, options, {
        locale: context.locale,
        defaultLocale: context.defaultLocale
      })));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.buildUrl = function buildUrl(path, params) {
    var url = new URL(path.charAt(0) === "/" ? "" + this.baseUrl + path : path);

    if (typeof params === "object" && "getQueryObject" in params) {
      params = params.getQueryObject();
    }

    if (params) {
      // Used instead URLSearchParams for nested params.
      url.search = stringify(params);
    }

    return url;
  };

  _proto.getAccessToken = function getAccessToken(opts) {
    try {
      var _this44 = this;

      if (_this44.accessToken && _this44.accessTokenScope === (opts == null ? void 0 : opts.scope)) {
        return Promise.resolve(_this44.accessToken);
      }

      if (!(opts != null && opts.clientId) || !(opts != null && opts.clientSecret)) {
        if (typeof _this44._auth === "undefined") {
          throw new Error("auth is not configured. See https://next-drupal.org/docs/client/auth");
        }
      }

      if (!isClientIdSecretAuth(_this44._auth) || opts && !isClientIdSecretAuth(opts)) {
        throw new Error("'clientId' and 'clientSecret' required. See https://next-drupal.org/docs/client/auth");
      }

      var clientId = (opts == null ? void 0 : opts.clientId) || _this44._auth.clientId;
      var clientSecret = (opts == null ? void 0 : opts.clientSecret) || _this44._auth.clientSecret;

      var url = _this44.buildUrl((opts == null ? void 0 : opts.url) || _this44._auth.url || DEFAULT_AUTH_URL);

      if (_this44.accessTokenScope === (opts == null ? void 0 : opts.scope) && _this44._token && Date.now() < _this44.tokenExpiresOn) {
        _this44._debug("Using existing access token.");

        return Promise.resolve(_this44._token);
      }

      _this44._debug("Fetching new access token.");

      var basic = Buffer.from(clientId + ":" + clientSecret).toString("base64");
      var body = "grant_type=client_credentials";

      if (opts != null && opts.scope) {
        body = body + "&scope=" + opts.scope;

        _this44._debug("Using scope: " + opts.scope);
      }

      return Promise.resolve(_this44.fetch(url.toString(), {
        method: "POST",
        headers: {
          Authorization: "Basic " + basic,
          Accept: "application/json",
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: body
      })).then(function (response) {
        function _temp67() {
          return Promise.resolve(response.json()).then(function (result) {
            _this44._debug(result);

            _this44.token = result;
            _this44.accessTokenScope = opts == null ? void 0 : opts.scope;
            return result;
          });
        }

        var _temp66 = function () {
          if (!(response != null && response.ok)) {
            return Promise.resolve(_this44.handleJsonApiErrors(response)).then(function () {});
          }
        }();

        return _temp66 && _temp66.then ? _temp66.then(_temp67) : _temp67(_temp66);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.deserialize = function deserialize(body, options) {
    if (!body) return null;
    return this.serializer.deserialize(body, options);
  };

  _proto.getErrorsFromResponse = function getErrorsFromResponse(response) {
    try {
      var _temp72 = function _temp72(_result11) {
        var _exit14;

        if (_exit15) return _result11;

        function _temp69(_result12) {
          return _exit14 ? _result12 : response.statusText;
        }

        var _temp68 = function () {
          if (type === "application/vnd.api+json") {
            return Promise.resolve(response.json()).then(function (_error) {
              var _error$errors2;

              if (_error != null && (_error$errors2 = _error.errors) != null && _error$errors2.length) {
                var _error$errors3 = _error.errors;
                _exit14 = 1;
                return _error$errors3;
              }
            });
          }
        }();

        // Construct error from response.
        // Check for type to ensure this is a JSON:API formatted error.
        // See https://jsonapi.org/format/#errors.
        return _temp68 && _temp68.then ? _temp68.then(_temp69) : _temp69(_temp68);
      };

      var _exit15;

      var type = response.headers.get("content-type");

      var _temp73 = function () {
        if (type === "application/json") {
          return Promise.resolve(response.json()).then(function (error) {
            var _error$message = error.message;
            _exit15 = 1;
            return _error$message;
          });
        }
      }();

      return Promise.resolve(_temp73 && _temp73.then ? _temp73.then(_temp72) : _temp72(_temp73));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.formatJsonApiErrors = function formatJsonApiErrors(errors) {
    var error = errors[0];
    var message = error.status + " " + error.title;

    if (error.detail) {
      message += "\n" + error.detail;
    }

    return message;
  };

  _proto._debug = function _debug(message) {
    !!this.debug && this.logger.debug(message);
  } // Error handling.
  // If throwErrors is enable, we show errors in the Next.js overlay.
  // Otherwise we log the errors even if debugging is turned off.
  // In production, errors are always logged never thrown.
  ;

  _proto.throwError = function throwError(error) {
    if (!this.throwJsonApiErrors) {
      return this.logger.error(error);
    }

    throw error;
  };

  _proto.handleJsonApiErrors = function handleJsonApiErrors(response) {
    try {
      var _this46 = this;

      return Promise.resolve(function () {
        if (!(response != null && response.ok)) {
          return Promise.resolve(_this46.getErrorsFromResponse(response)).then(function (errors) {
            throw new JsonApiErrors(errors, response.status);
          });
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getAuthFromContextAndOptions = function getAuthFromContextAndOptions(context, options) {
    var _context$previewData;

    // If not in preview or withAuth is provided, use that.
    if (!context.preview) {
      // If we have provided an auth, use that.
      if (typeof (options == null ? void 0 : options.withAuth) !== "undefined") {
        return options.withAuth;
      } // Otherwise we fallback to the global auth.


      return this.withAuth;
    } // If no plugin is provided, return.


    var plugin = (_context$previewData = context.previewData) == null ? void 0 : _context$previewData["plugin"];

    if (!plugin) {
      return null;
    }

    var withAuth = this._auth;

    if (plugin === "simple_oauth") {
      var _context$previewData2;

      // If we are using a client id and secret auth, pass the scope.
      if (isClientIdSecretAuth(withAuth) && (_context$previewData2 = context.previewData) != null && _context$previewData2["scope"]) {
        var _context$previewData3;

        withAuth = _extends({}, withAuth, {
          scope: (_context$previewData3 = context.previewData) == null ? void 0 : _context$previewData3["scope"]
        });
      }
    }

    if (plugin === "jwt") {
      var _context$previewData4;

      var accessToken = (_context$previewData4 = context.previewData) == null ? void 0 : _context$previewData4["access_token"];

      if (accessToken) {
        return "Bearer " + accessToken;
      }
    }

    return withAuth;
  };

  _createClass(DrupalClient, [{
    key: "apiPrefix",
    get: function get() {
      return this._apiPrefix;
    },
    set: function set(apiPrefix) {
      this._apiPrefix = apiPrefix.charAt(0) === "/" ? apiPrefix : "/" + apiPrefix;
    }
  }, {
    key: "auth",
    set: function set(auth) {
      if (typeof auth === "object") {
        if (isBasicAuth(auth)) {
          if (!auth.username || !auth.password) {
            throw new Error("'username' and 'password' are required for auth. See https://next-drupal.org/docs/client/auth");
          }
        } else if (isAccessTokenAuth(auth)) {
          if (!auth.access_token || !auth.token_type) {
            throw new Error("'access_token' and 'token_type' are required for auth. See https://next-drupal.org/docs/client/auth");
          }
        } else if (!auth.clientId || !auth.clientSecret) {
          throw new Error("'clientId' and 'clientSecret' are required for auth. See https://next-drupal.org/docs/client/auth");
        }

        auth = _extends({
          url: DEFAULT_AUTH_URL
        }, auth);
      }

      this._auth = auth;
    }
  }, {
    key: "headers",
    set: function set(value) {
      this._headers = value;
    }
  }, {
    key: "token",
    set: function set(token) {
      this._token = token;
      this.tokenExpiresOn = Date.now() + token.expires_in * 1000;
    }
  }]);

  return DrupalClient;
}();

export { DrupalClient, DrupalPreview, JsonApiErrors, PreviewHandler, buildUrl, deserialize, getAccessToken, getJsonApiIndex, getJsonApiPathForResourceType, getMenu, getPathsFromContext, getResource, getResourceByPath, getResourceCollection, getResourceCollectionFromContext, getResourceFromContext, getResourcePreviewUrl, getResourceTypeFromContext, getSearchIndex, getSearchIndexFromContext, getView, syncDrupalPreviewRoutes, translatePath, translatePathFromContext, useMenu };
//# sourceMappingURL=index.esm.js.map
