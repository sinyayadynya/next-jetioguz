import NodeCache from 'node-cache';
import Jsona from 'jsona';
import { stringify } from 'qs';
import * as React from 'react';
import { useRouter } from 'next/router';

const cache = new NodeCache();

const CACHE_KEY = "NEXT_DRUPAL_ACCESS_TOKEN";
async function getAccessToken() {
  if (!process.env.DRUPAL_CLIENT_ID || !process.env.DRUPAL_CLIENT_SECRET) {
    return null;
  }

  const cached = cache.get(CACHE_KEY);

  if (cached != null && cached.access_token) {
    return cached;
  }

  const basic = Buffer.from(`${process.env.DRUPAL_CLIENT_ID}:${process.env.DRUPAL_CLIENT_SECRET}`).toString("base64");
  const response = await fetch(`${process.env.NEXT_PUBLIC_DRUPAL_BASE_URL}/oauth/token`, {
    method: "POST",
    headers: {
      Authorization: `Basic ${basic}`,
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: `grant_type=client_credentials`
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const result = await response.json();
  cache.set(CACHE_KEY, result, result.expires_in);
  return result;
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const JSONAPI_PREFIX = process.env.DRUPAL_JSONAPI_PREFIX || "/jsonapi";
const dataFormatter = new Jsona();
function deserialize(body, options) {
  if (!body) return null;
  return dataFormatter.deserialize(body, options);
}
async function getJsonApiPathForResourceType(type, locale) {
  var _index$links$type;

  const index = await getJsonApiIndex(locale);
  return index == null ? void 0 : (_index$links$type = index.links[type]) == null ? void 0 : _index$links$type.href;
}
async function getJsonApiIndex(locale, options) {
  const url = buildUrl(locale ? `/${locale}${JSONAPI_PREFIX}` : `${JSONAPI_PREFIX}`); // As per https://www.drupal.org/node/2984034 /jsonapi is public.
  // We only call buildHeaders if accessToken or locale is explicitly set.
  // This is for rare cases where /jsonapi might be protected.

  const response = await fetch(url.toString(), {
    headers: locale || options ? await buildHeaders(options) : {
      "Content-Type": "application/json"
    }
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  return await response.json();
}
function buildUrl(path, params) {
  const url = new URL(path.charAt(0) === "/" ? `${process.env.NEXT_PUBLIC_DRUPAL_BASE_URL}${path}` : path);

  if (params) {
    // Use instead URLSearchParams for nested params.
    url.search = stringify(params);
  }

  return url;
}
async function buildHeaders({
  accessToken,
  headers = {
    "Content-Type": "application/json"
  }
} = {}) {
  // This allows an access_token (preferrably long-lived) to be set directly on the env.
  // This reduces the number of OAuth call to the Drupal server.
  // Intentionally marked as unstable for now.
  if (process.env.UNSTABLE_DRUPAL_ACCESS_TOKEN) {
    headers["Authorization"] = `Bearer ${process.env.UNSTABLE_DRUPAL_ACCESS_TOKEN}`;
    return headers;
  }

  const token = accessToken || (await getAccessToken());

  if (token) {
    headers["Authorization"] = `Bearer ${token.access_token}`;
  }

  return headers;
}
function getPathFromContext(context, prefix = "") {
  let {
    slug
  } = context.params;
  slug = Array.isArray(slug) ? slug.map(s => encodeURIComponent(s)).join("/") : slug; // Handle locale.

  if (context.locale && context.locale !== context.defaultLocale) {
    slug = `/${context.locale}/${slug}`;
  }

  return !slug ? process.env.DRUPAL_FRONT_PAGE : prefix ? `${prefix}/${slug}` : slug;
}
function syncDrupalPreviewRoutes(path) {
  if (window && window.top !== window.self) {
    window.parent.postMessage({
      type: "NEXT_DRUPAL_ROUTE_SYNC",
      path
    }, process.env.NEXT_PUBLIC_DRUPAL_BASE_URL);
  }
}

async function getMenu(name, options) {
  var _options;

  options = _extends({
    deserialize: true
  }, options);
  const localePrefix = (_options = options) != null && _options.locale && options.locale !== options.defaultLocale ? `/${options.locale}` : "";
  const url = buildUrl(`${localePrefix}/jsonapi/menu_items/${name}`);
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const data = await response.json();
  const items = options.deserialize ? deserialize(data) : data;
  const {
    items: tree
  } = buildMenuTree(items);
  return {
    items,
    tree
  };
}

function buildMenuTree(links, parent = "") {
  if (!(links != null && links.length)) {
    return {
      items: []
    };
  }

  const children = links.filter(link => link.parent === parent);
  return children.length ? {
    items: children.map(link => _extends({}, link, buildMenuTree(links, link.id)))
  } : {};
}

async function getResourceCollection(type, options) {
  var _options, _options2, _options3;

  options = _extends({
    deserialize: true
  }, options);
  const apiPath = await getJsonApiPathForResourceType(type, ((_options = options) == null ? void 0 : _options.locale) !== ((_options2 = options) == null ? void 0 : _options2.defaultLocale) ? options.locale : undefined);

  if (!apiPath) {
    throw new Error(`Error: resource of type ${type} not found.`);
  }

  const url = buildUrl(apiPath, _extends({}, (_options3 = options) == null ? void 0 : _options3.params));
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const json = await response.json();
  return options.deserialize ? deserialize(json) : json;
}
async function getResourceCollectionFromContext(type, context, options) {
  options = _extends({
    deserialize: true
  }, options); // // Filter out unpublished entities.
  // if (!context.preview) {
  //   options.params = {
  //     "filter[status]": "1",
  //     ...options.params,
  //   }
  // }

  return await getResourceCollection(type, _extends({}, options, {
    locale: context.locale,
    defaultLocale: context.defaultLocale
  }));
}

async function getPathsFromContext(types, context, options = {}) {
  if (typeof types === "string") {
    types = [types];
  }

  const paths = await Promise.all(types.map(async type => {
    var _context$locales;

    // Use sparse fieldset to expand max size.
    options.params = _extends({
      [`fields[${type}]`]: "path"
    }, options == null ? void 0 : options.params); // const paths = await Promise.all(
    //   context.locales.map(async (locale) => {
    //     const resources = await getResourceCollection(type, {
    //       deserialize: true,
    //       locale,
    //       defaultLocale: context.defaultLocale,
    //       ...options,
    //     })
    //     return buildPathsFromResources(resources, locale)
    //   })
    // )
    // return paths.flat()
    // Handle localized path aliases

    if (!((_context$locales = context.locales) != null && _context$locales.length)) {
      const resources = await getResourceCollection(type, _extends({
        deserialize: true
      }, options));
      return buildPathsFromResources(resources);
    }

    const paths = await Promise.all(context.locales.map(async locale => {
      const resources = await getResourceCollection(type, _extends({
        deserialize: true,
        locale,
        defaultLocale: context.defaultLocale
      }, options));
      return buildPathsFromResources(resources, locale);
    }));
    return paths.flat();
  }));
  return paths.flat();
}

function buildPathsFromResources(resources, locale) {
  return resources == null ? void 0 : resources.flatMap(resource => {
    var _resource$path, _resource$path2;

    const slug = (resource == null ? void 0 : (_resource$path = resource.path) == null ? void 0 : _resource$path.alias) === process.env.DRUPAL_FRONT_PAGE ? "/" : resource == null ? void 0 : (_resource$path2 = resource.path) == null ? void 0 : _resource$path2.alias;
    const path = {
      params: {
        slug: `${slug == null ? void 0 : slug.replace(/^\/|\/$/g, "")}`.split("/")
      }
    };

    if (locale) {
      path["locale"] = locale;
    }

    return path;
  });
}

const _excluded$1 = ["resourceVersion"];
async function getResourceFromContext(type, context, options) {
  var _options, _options2;

  options = _extends({
    deserialize: true,
    // Add support for revisions for node by default.
    // TODO: Make this required before stable?
    isVersionable: /^node--/.test(type)
  }, options);
  const path = getPathFromContext(context, (_options = options) == null ? void 0 : _options.prefix); // Filter out unpublished entities.
  // if (!context.preview) {
  //   options.params = {
  //     "filter[status]": "1",
  //     ...options?.params,
  //   }
  // }

  const previewData = context.previewData;
  const resource = await getResourceByPath(path, {
    deserialize: options.deserialize,
    isVersionable: options.isVersionable,
    locale: context.locale,
    defaultLocale: context.defaultLocale,
    params: _extends({
      resourceVersion: previewData == null ? void 0 : previewData.resourceVersion
    }, (_options2 = options) == null ? void 0 : _options2.params)
  }); // If no locale is passed, skip entity if not default_langcode.
  // This happens because decoupled_router will still translate the path
  // to a resource.
  // TODO: Figure out if we want this behavior.
  // For now this causes a bug where a non-i18n sites builds (ISR) pages for
  // localized pages.
  // if (!context.locale && !resource?.default_langcode) {
  //   return null
  // }

  return resource;
}
async function getResourceByPath(path, options) {
  var _json$resolvedResourc;

  options = _extends({
    deserialize: true,
    isVersionable: false,
    params: {}
  }, options);

  if (!path) {
    return null;
  }

  if (options.locale && options.defaultLocale && path.indexOf(options.locale) !== 1) {
    path = path === "/" ? path : path.replace(/^\/+/, "");
    path = getPathFromContext({
      params: {
        slug: [path]
      },
      locale: options.locale,
      defaultLocale: options.defaultLocale
    });
  }

  const _options$params = options.params,
        {
    resourceVersion = "rel:latest-version"
  } = _options$params,
        params = _objectWithoutPropertiesLoose(_options$params, _excluded$1);

  if (options.isVersionable) {
    params.resourceVersion = resourceVersion;
  }

  const resourceParams = stringify(params);
  const payload = [{
    requestId: "router",
    action: "view",
    uri: `/router/translate-path?path=${path}&_format=json`,
    headers: {
      Accept: "application/vnd.api+json"
    }
  }, {
    requestId: "resolvedResource",
    action: "view",
    uri: `{{router.body@$.jsonapi.individual}}?${resourceParams.toString()}`,
    waitFor: ["router"]
  }]; // Localized subrequests.
  // I was hoping we would not need this but it seems like subrequests is not properly
  // setting the jsonapi locale from a translated path.

  let subrequestsPath = "/subrequests";

  if (options.locale && options.defaultLocale && options.locale !== options.defaultLocale) {
    subrequestsPath = `/${options.locale}/subrequests`;
  }

  const url = buildUrl(subrequestsPath, {
    _format: "json"
  });
  const response = await fetch(url.toString(), {
    method: "POST",
    credentials: "include",
    headers: await buildHeaders(options),
    redirect: "follow",
    body: JSON.stringify(payload)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const json = await response.json();

  if (!json["resolvedResource#uri{0}"]) {
    return null;
  }

  const data = JSON.parse((_json$resolvedResourc = json["resolvedResource#uri{0}"]) == null ? void 0 : _json$resolvedResourc.body);

  if (data.errors) {
    throw new Error(data.errors[0].detail);
  }

  return options.deserialize ? deserialize(data) : data;
}
async function getResource(type, uuid, options) {
  var _options3, _options4, _options5;

  options = _extends({
    deserialize: true,
    params: {}
  }, options);
  const apiPath = await getJsonApiPathForResourceType(type, ((_options3 = options) == null ? void 0 : _options3.locale) !== ((_options4 = options) == null ? void 0 : _options4.defaultLocale) ? options.locale : undefined);

  if (!apiPath) {
    throw new Error(`Error: resource of type ${type} not found.`);
  }

  const url = buildUrl(`${apiPath}/${uuid}`, _extends({}, (_options5 = options) == null ? void 0 : _options5.params));
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const json = await response.json();
  return options.deserialize ? deserialize(json) : json;
}

function DrupalPreview(options) {
  return (request, response) => PreviewHandler(request, response, options);
}
async function PreviewHandler(request, response, options) {
  const {
    slug,
    resourceVersion,
    secret,
    locale,
    defaultLocale
  } = request.query;

  if (secret !== process.env.DRUPAL_PREVIEW_SECRET) {
    return response.status(401).json({
      message: (options == null ? void 0 : options.errorMessages.secret) || "Invalid preview secret."
    });
  }

  if (!slug) {
    return response.status(401).end({
      message: (options == null ? void 0 : options.errorMessages.slug) || "Invalid slug."
    });
  }

  let _options = {
    isVersionable: typeof resourceVersion !== "undefined"
  };

  if (locale && defaultLocale) {
    _options = _extends({}, _options, {
      locale: locale,
      defaultLocale: defaultLocale
    });
  }

  const url = await getResourcePreviewUrl(slug, _options);

  if (!url) {
    response.status(404).end({
      message: (options == null ? void 0 : options.errorMessages.slug) || "Invalid slug"
    });
  }

  response.setPreviewData({
    resourceVersion
  });
  response.writeHead(307, {
    Location: url
  });
  return response.end();
}
async function getResourcePreviewUrl(slug, options) {
  const entity = await getResourceByPath(slug, options);

  if (!entity) {
    return null;
  }

  if (!(entity != null && entity.path)) {
    throw new Error(`Error: the path attribute is missing for entity type ${entity.type}`);
  }

  return entity != null && entity.default_langcode ? entity.path.alias : `/${entity.path.langcode}${entity.path.alias}`;
}

async function translatePath(path, options) {
  const url = buildUrl("/router/translate-path", {
    path
  });
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    return null;
  }

  const json = await response.json();
  return json;
}
async function translatePathFromContext(context, options) {
  options = _extends({
    prefix: ""
  }, options);
  const path = getPathFromContext(context, options.prefix);
  const response = await translatePath(path, {
    accessToken: options.accessToken
  });
  return response;
}

async function getResourceTypeFromContext(context, options) {
  try {
    const response = await translatePathFromContext(context, options);
    return response.jsonapi.resourceName;
  } catch (error) {
    return null;
  }
}

async function getSearchIndex(name, options) {
  var _options;

  options = _extends({
    deserialize: true
  }, options);
  const localePrefix = (_options = options) != null && _options.locale && options.locale !== options.defaultLocale ? `/${options.locale}` : "";
  const url = buildUrl(`${localePrefix}/jsonapi/index/${name}`, options.params);
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const json = await response.json();
  return options.deserialize ? deserialize(json) : json;
}
async function getSearchIndexFromContext(name, context, options) {
  options = _extends({
    deserialize: true
  }, options);
  return await getSearchIndex(name, _extends({}, options, {
    locale: context.locale,
    defaultLocale: context.defaultLocale
  }));
}

async function getView(name, options) {
  var _options;

  options = _extends({
    deserialize: true
  }, options);
  const localePrefix = (_options = options) != null && _options.locale && options.locale !== options.defaultLocale ? `/${options.locale}` : "";
  const [viewId, displayId] = name.split("--");
  const url = buildUrl(`${localePrefix}/jsonapi/views/${viewId}/${displayId}`, options.params);
  const response = await fetch(url.toString(), {
    headers: await buildHeaders(options)
  });

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const data = await response.json();
  const results = options.deserialize ? deserialize(data) : data;
  return {
    results,
    meta: data.meta,
    links: data.links
  };
}

function useMenu(name) {
  const router = useRouter();
  const [data, setData] = React.useState(null);
  const [error, setError] = React.useState(null);
  const [isLoading, setIsLoading] = React.useState(false);
  React.useEffect(() => {
    const fetchMenuItems = async () => {
      setIsLoading(true);

      try {
        const data = await getMenu(name, {
          locale: router.locale,
          defaultLocale: router.defaultLocale
        });
        setData(data);
        setIsLoading(false);
      } catch (error) {
        setError(error);
        setIsLoading(false);
      }
    };

    fetchMenuItems();
  }, [router.locale]);
  return _extends({}, data, {
    error,
    isLoading
  });
}

// Default logger. Uses console.
const logger = {
  log(message) {
    console.log(`[next-drupal][log]:`, message);
  },

  debug(message) {
    console.debug(`[next-drupal][debug]:`, message);
  },

  warn(message) {
    console.warn(`[next-drupal][debug]:`, message);
  },

  error(message) {
    console.error(`[next-drupal][error]:`, message);
  }

};

class JsonApiErrors extends Error {
  constructor(errors, statusCode) {
    super();
    this.errors = void 0;
    this.statusCode = void 0;
    this.errors = errors;
    this.statusCode = statusCode;
    this.message = JsonApiErrors.formatMessage(errors);
  }

  static formatMessage(errors) {
    if (typeof errors === "string") {
      return errors;
    }

    const [error] = errors;
    let message = `${error.status} ${error.title}`;

    if (error.detail) {
      message += `\n${error.detail}`;
    }

    return message;
  }

}

const _excluded = ["resourceVersion"];
const DEFAULT_API_PREFIX = "/jsonapi";
const DEFAULT_FRONT_PAGE = "/home";
const DEFAULT_WITH_AUTH = false; // From simple_oauth.

const DEFAULT_AUTH_URL = "/oauth/token"; // See https://jsonapi.org/format/#content-negotiation.

const DEFAULT_HEADERS = {
  "Content-Type": "application/vnd.api+json",
  Accept: "application/vnd.api+json"
};

function isBasicAuth(auth) {
  return (auth == null ? void 0 : auth.username) !== undefined || (auth == null ? void 0 : auth.password) !== undefined;
}

function isAccessTokenAuth(auth) {
  return (auth == null ? void 0 : auth.access_token) !== undefined;
}

function isClientIdSecretAuth(auth) {
  return (auth == null ? void 0 : auth.clientId) !== undefined || (auth == null ? void 0 : auth.clientSecret) !== undefined;
}

class DrupalClient {
  /**
   * Instantiates a new DrupalClient.
   *
   * const client = new DrupalClient(baseUrl)
   *
   * @param {baseUrl} baseUrl The baseUrl of your Drupal site. Do not add the /jsonapi suffix.
   * @param {options} options Options for the client. See Experiment_DrupalClientOptions.
   */
  constructor(baseUrl, options = {}) {
    this.baseUrl = void 0;
    this.debug = void 0;
    this.frontPage = void 0;
    this.serializer = void 0;
    this.cache = void 0;
    this.throwJsonApiErrors = void 0;
    this.logger = void 0;
    this.fetcher = void 0;
    this._headers = void 0;
    this._auth = void 0;
    this._apiPrefix = void 0;
    this.useDefaultResourceTypeEntry = void 0;
    this._token = void 0;
    this.accessToken = void 0;
    this.accessTokenScope = void 0;
    this.tokenExpiresOn = void 0;
    this.withAuth = void 0;
    this.previewSecret = void 0;
    this.forceIframeSameSiteCookie = void 0;
    this.getPathsFromContext = this.getStaticPathsFromContext;

    if (!baseUrl || typeof baseUrl !== "string") {
      throw new Error("The 'baseUrl' param is required.");
    }

    const {
      apiPrefix = DEFAULT_API_PREFIX,
      serializer = new Jsona(),
      cache = null,
      debug = false,
      frontPage = DEFAULT_FRONT_PAGE,
      useDefaultResourceTypeEntry = false,
      headers = DEFAULT_HEADERS,
      logger: logger$1 = logger,
      withAuth = DEFAULT_WITH_AUTH,
      fetcher,
      auth,
      previewSecret,
      accessToken,
      forceIframeSameSiteCookie = false,
      throwJsonApiErrors = true
    } = options;
    this.baseUrl = baseUrl;
    this.apiPrefix = apiPrefix;
    this.serializer = serializer;
    this.frontPage = frontPage;
    this.debug = debug;
    this.useDefaultResourceTypeEntry = useDefaultResourceTypeEntry;
    this.fetcher = fetcher;
    this.auth = auth;
    this.headers = headers;
    this.logger = logger$1;
    this.withAuth = withAuth;
    this.previewSecret = previewSecret;
    this.cache = cache;
    this.accessToken = accessToken;
    this.forceIframeSameSiteCookie = forceIframeSameSiteCookie;
    this.throwJsonApiErrors = throwJsonApiErrors; // Do not throw errors in production.

    if (process.env.NODE_ENV === "production") {
      this.throwJsonApiErrors = false;
    }

    this._debug("Debug mode is on.");
  }

  set apiPrefix(apiPrefix) {
    this._apiPrefix = apiPrefix.charAt(0) === "/" ? apiPrefix : `/${apiPrefix}`;
  }

  get apiPrefix() {
    return this._apiPrefix;
  }

  set auth(auth) {
    if (typeof auth === "object") {
      if (isBasicAuth(auth)) {
        if (!auth.username || !auth.password) {
          throw new Error(`'username' and 'password' are required for auth. See https://next-drupal.org/docs/client/auth`);
        }
      } else if (isAccessTokenAuth(auth)) {
        if (!auth.access_token || !auth.token_type) {
          throw new Error(`'access_token' and 'token_type' are required for auth. See https://next-drupal.org/docs/client/auth`);
        }
      } else if (!auth.clientId || !auth.clientSecret) {
        throw new Error(`'clientId' and 'clientSecret' are required for auth. See https://next-drupal.org/docs/client/auth`);
      }

      auth = _extends({
        url: DEFAULT_AUTH_URL
      }, auth);
    }

    this._auth = auth;
  }

  set headers(value) {
    this._headers = value;
  }

  set token(token) {
    this._token = token;
    this.tokenExpiresOn = Date.now() + token.expires_in * 1000;
  }
  /* eslint-disable @typescript-eslint/no-explicit-any */


  async fetch(input, init) {
    var _init, _init2;

    init = _extends({}, init, {
      credentials: "include",
      headers: _extends({}, this._headers, (_init = init) == null ? void 0 : _init.headers)
    }); // Using the auth set on the client.
    // TODO: Abstract this to a re-usable.

    if ((_init2 = init) != null && _init2.withAuth) {
      this._debug(`Using authenticated request.`);

      if (init.withAuth === true) {
        if (typeof this._auth === "undefined") {
          throw new Error("auth is not configured. See https://next-drupal.org/docs/client/auth");
        } // By default, if withAuth is set to true, we use the auth configured
        // in the client constructor.


        if (typeof this._auth === "function") {
          this._debug(`Using custom auth callback.`);

          init["headers"]["Authorization"] = this._auth();
        } else if (typeof this._auth === "string") {
          this._debug(`Using custom authorization header.`);

          init["headers"]["Authorization"] = this._auth;
        } else if (typeof this._auth === "object") {
          this._debug(`Using custom auth credentials.`);

          if (isBasicAuth(this._auth)) {
            const basic = Buffer.from(`${this._auth.username}:${this._auth.password}`).toString("base64");
            init["headers"]["Authorization"] = `Basic ${basic}`;
          } else if (isClientIdSecretAuth(this._auth)) {
            // Use the built-in client_credentials grant.
            this._debug(`Using default auth (client_credentials).`); // Fetch an access token and add it to the request.
            // Access token can be fetched from cache or using a custom auth method.


            const token = await this.getAccessToken(this._auth);

            if (token) {
              init["headers"]["Authorization"] = `Bearer ${token.access_token}`;
            }
          } else if (isAccessTokenAuth(this._auth)) {
            init["headers"]["Authorization"] = `${this._auth.token_type} ${this._auth.access_token}`;
          }
        }
      } else if (typeof init.withAuth === "string") {
        this._debug(`Using custom authorization header.`);

        init["headers"]["Authorization"] = init.withAuth;
      } else if (typeof init.withAuth === "function") {
        this._debug(`Using custom authorization callback.`);

        init["headers"]["Authorization"] = init.withAuth();
      } else if (isBasicAuth(init.withAuth)) {
        this._debug(`Using basic authorization header`);

        const basic = Buffer.from(`${init.withAuth.username}:${init.withAuth.password}`).toString("base64");
        init["headers"]["Authorization"] = `Basic ${basic}`;
      } else if (isClientIdSecretAuth(init.withAuth)) {
        // Fetch an access token and add it to the request.
        // Access token can be fetched from cache or using a custom auth method.
        const token = await this.getAccessToken(init.withAuth);

        if (token) {
          init["headers"]["Authorization"] = `Bearer ${token.access_token}`;
        }
      } else if (isAccessTokenAuth(init.withAuth)) {
        init["headers"]["Authorization"] = `${init.withAuth.token_type} ${init.withAuth.access_token}`;
      }
    }

    if (this.fetcher) {
      this._debug(`Using custom fetcher.`);

      return await this.fetcher(input, init);
    }

    this._debug(`Using default fetch (polyfilled by Next.js).`);

    return await fetch(input, init);
  }

  async createResource(type, body, options) {
    var _options2, _options3, _options4;

    options = _extends({
      deserialize: true,
      withAuth: true
    }, options);
    const apiPath = await this.getEntryForResourceType(type, ((_options2 = options) == null ? void 0 : _options2.locale) !== ((_options3 = options) == null ? void 0 : _options3.defaultLocale) ? options.locale : undefined);
    const url = this.buildUrl(apiPath, (_options4 = options) == null ? void 0 : _options4.params);

    this._debug(`Creating resource of type ${type}.`);

    this._debug(url.toString()); // Add type to body.


    body.data.type = type;
    const response = await this.fetch(url.toString(), {
      method: "POST",
      body: JSON.stringify(body),
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    const json = await response.json();
    return options.deserialize ? this.deserialize(json) : json;
  }

  async createFileResource(type, body, options) {
    var _body$data, _body$data$attributes, _options5, _options6, _options7;

    options = _extends({
      deserialize: true,
      withAuth: true
    }, options);
    const hostType = body == null ? void 0 : (_body$data = body.data) == null ? void 0 : (_body$data$attributes = _body$data.attributes) == null ? void 0 : _body$data$attributes.type;
    const apiPath = await this.getEntryForResourceType(hostType, ((_options5 = options) == null ? void 0 : _options5.locale) !== ((_options6 = options) == null ? void 0 : _options6.defaultLocale) ? options.locale : undefined);
    const url = this.buildUrl(`${apiPath}/${body.data.attributes.field}`, (_options7 = options) == null ? void 0 : _options7.params);

    this._debug(`Creating file resource for media of type ${type}.`);

    this._debug(url.toString());

    const response = await this.fetch(url.toString(), {
      method: "POST",
      headers: {
        "Content-Type": "application/octet-stream",
        Accept: "application/vnd.api+json",
        "Content-Disposition": `file; filename="${body.data.attributes.filename}"`
      },
      body: body.data.attributes.file,
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    const json = await response.json();
    return options.deserialize ? this.deserialize(json) : json;
  }

  async updateResource(type, uuid, body, options) {
    var _options8, _options9, _options10;

    options = _extends({
      deserialize: true,
      withAuth: true
    }, options);
    const apiPath = await this.getEntryForResourceType(type, ((_options8 = options) == null ? void 0 : _options8.locale) !== ((_options9 = options) == null ? void 0 : _options9.defaultLocale) ? options.locale : undefined);
    const url = this.buildUrl(`${apiPath}/${uuid}`, (_options10 = options) == null ? void 0 : _options10.params);

    this._debug(`Updating resource of type ${type} with id ${uuid}.`);

    this._debug(url.toString()); // Update body.


    body.data.type = type;
    body.data.id = uuid;
    const response = await this.fetch(url.toString(), {
      method: "PATCH",
      body: JSON.stringify(body),
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    const json = await response.json();
    return options.deserialize ? this.deserialize(json) : json;
  }

  async deleteResource(type, uuid, options) {
    var _options11, _options12, _options13;

    options = _extends({
      withAuth: true,
      params: {}
    }, options);
    const apiPath = await this.getEntryForResourceType(type, ((_options11 = options) == null ? void 0 : _options11.locale) !== ((_options12 = options) == null ? void 0 : _options12.defaultLocale) ? options.locale : undefined);
    const url = this.buildUrl(`${apiPath}/${uuid}`, (_options13 = options) == null ? void 0 : _options13.params);

    this._debug(`Deleting resource of type ${type} with id ${uuid}.`);

    this._debug(url.toString());

    const response = await this.fetch(url.toString(), {
      method: "DELETE",
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    return response.status === 204;
  }

  async getResource(type, uuid, options) {
    var _options14, _options15, _options16;

    options = _extends({
      deserialize: true,
      withAuth: this.withAuth,
      withCache: false,
      params: {}
    }, options);

    if (options.withCache) {
      const cached = await this.cache.get(options.cacheKey);

      if (cached) {
        this._debug(`Returning cached resource ${type} with id ${uuid}`);

        const _json = JSON.parse(cached);

        return options.deserialize ? this.deserialize(_json) : _json;
      }
    }

    const apiPath = await this.getEntryForResourceType(type, ((_options14 = options) == null ? void 0 : _options14.locale) !== ((_options15 = options) == null ? void 0 : _options15.defaultLocale) ? options.locale : undefined);
    const url = this.buildUrl(`${apiPath}/${uuid}`, (_options16 = options) == null ? void 0 : _options16.params);

    this._debug(`Fetching resource ${type} with id ${uuid}.`);

    this._debug(url.toString());

    const response = await this.fetch(url.toString(), {
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    const json = await response.json();

    if (options.withCache) {
      await this.cache.set(options.cacheKey, JSON.stringify(json));
    }

    return options.deserialize ? this.deserialize(json) : json;
  }

  async getResourceFromContext(input, context, options) {
    var _options17, _options18, _options19;

    const type = typeof input === "string" ? input : input.jsonapi.resourceName;
    const previewData = context.previewData;
    options = _extends({
      deserialize: true,
      pathPrefix: "/",
      withAuth: this.getAuthFromContextAndOptions(context, options),
      params: {}
    }, options);
    const _options = {
      deserialize: options.deserialize,
      isVersionable: options.isVersionable,
      locale: context.locale,
      defaultLocale: context.defaultLocale,
      withAuth: (_options17 = options) == null ? void 0 : _options17.withAuth,
      params: (_options18 = options) == null ? void 0 : _options18.params
    }; // Check if resource is versionable.
    // Add support for revisions for node by default.

    const isVersionable = options.isVersionable || /^node--/.test(type); // If the resource is versionable and no resourceVersion is supplied via params.
    // Use the resourceVersion from previewData or fallback to the latest version.

    if (isVersionable && typeof options.params.resourceVersion === "undefined") {
      options.params.resourceVersion = (previewData == null ? void 0 : previewData.resourceVersion) || "rel:latest-version";
    }

    if (typeof input !== "string") {
      var _input$entity;

      // Fix for subrequests and translation.
      // TODO: Confirm if we still need this after https://www.drupal.org/i/3111456.
      // @shadcn, note to self:
      // Given an entity at /example with no translation.
      // When we try to translate /es/example, decoupled router will properly
      // translate to the untranslated version and set the locale to es.
      // However a subrequests to /es/subrequests for decoupled router will fail.
      if (context.locale && input.entity.langcode !== context.locale) {
        context.locale = input.entity.langcode;
      } // Given we already have the path info, we can skip subrequests and just make a simple
      // request to the Drupal site to get the entity.


      if ((_input$entity = input.entity) != null && _input$entity.uuid) {
        return await this.getResource(type, input.entity.uuid, _options);
      }
    }

    const path = this.getPathFromContext(context, {
      pathPrefix: (_options19 = options) == null ? void 0 : _options19.pathPrefix
    });
    const resource = await this.getResourceByPath(path, _options); // If no locale is passed, skip entity if not default_langcode.
    // This happens because decoupled_router will still translate the path
    // to a resource.
    // TODO: Figure out if we want this behavior.
    // For now this causes a bug where a non-i18n sites builds (ISR) pages for
    // localized pages.
    // if (!context.locale && !resource?.default_langcode) {
    //   return null
    // }

    return resource;
  }

  async getResourceByPath(path, options) {
    var _json$resolvedResourc, _json$resolvedResourc2;

    options = _extends({
      deserialize: true,
      isVersionable: false,
      withAuth: this.withAuth,
      params: {}
    }, options);

    if (!path) {
      return null;
    }

    if (options.locale && options.defaultLocale && path.indexOf(options.locale) !== 1) {
      path = path === "/" ? path : path.replace(/^\/+/, "");
      path = this.getPathFromContext({
        params: {
          slug: [path]
        },
        locale: options.locale,
        defaultLocale: options.defaultLocale
      });
    } // If a resourceVersion is provided, assume entity type is versionable.


    if (options.params.resourceVersion) {
      options.isVersionable = true;
    }

    const _options$params = options.params,
          {
      resourceVersion = "rel:latest-version"
    } = _options$params,
          params = _objectWithoutPropertiesLoose(_options$params, _excluded);

    if (options.isVersionable) {
      params.resourceVersion = resourceVersion;
    }

    const resourceParams = stringify(params); // We are intentionally not using translatePath here.
    // We want a single request using subrequests.

    const payload = [{
      requestId: "router",
      action: "view",
      uri: `/router/translate-path?path=${path}&_format=json`,
      headers: {
        Accept: "application/vnd.api+json"
      }
    }, {
      requestId: "resolvedResource",
      action: "view",
      uri: `{{router.body@$.jsonapi.individual}}?${resourceParams.toString()}`,
      waitFor: ["router"]
    }]; // Localized subrequests.
    // I was hoping we would not need this but it seems like subrequests is not properly
    // setting the jsonapi locale from a translated path.
    // TODO: Confirm if we still need this after https://www.drupal.org/i/3111456.

    let subrequestsPath = "/subrequests";

    if (options.locale && options.defaultLocale && options.locale !== options.defaultLocale) {
      subrequestsPath = `/${options.locale}/subrequests`;
    }

    const url = this.buildUrl(subrequestsPath, {
      _format: "json"
    });
    const response = await this.fetch(url.toString(), {
      method: "POST",
      credentials: "include",
      redirect: "follow",
      body: JSON.stringify(payload),
      withAuth: options.withAuth
    });
    const json = await response.json();

    if (!(json != null && (_json$resolvedResourc = json["resolvedResource#uri{0}"]) != null && _json$resolvedResourc.body)) {
      var _json$router;

      if (json != null && (_json$router = json.router) != null && _json$router.body) {
        const error = JSON.parse(json.router.body);

        if (error != null && error.message) {
          this.throwError(new Error(error.message));
        }
      }

      return null;
    }

    const data = JSON.parse((_json$resolvedResourc2 = json["resolvedResource#uri{0}"]) == null ? void 0 : _json$resolvedResourc2.body);

    if (data.errors) {
      this.throwError(new Error(this.formatJsonApiErrors(data.errors)));
    }

    return options.deserialize ? this.deserialize(data) : data;
  }

  async getResourceCollection(type, options) {
    var _options20, _options21, _options22;

    options = _extends({
      withAuth: this.withAuth,
      deserialize: true
    }, options);
    const apiPath = await this.getEntryForResourceType(type, ((_options20 = options) == null ? void 0 : _options20.locale) !== ((_options21 = options) == null ? void 0 : _options21.defaultLocale) ? options.locale : undefined);
    const url = this.buildUrl(apiPath, _extends({}, (_options22 = options) == null ? void 0 : _options22.params));

    this._debug(`Fetching resource collection of type ${type}`);

    this._debug(url.toString());

    const response = await this.fetch(url.toString(), {
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    const json = await response.json();
    return options.deserialize ? this.deserialize(json) : json;
  }

  async getResourceCollectionFromContext(type, context, options) {
    options = _extends({
      deserialize: true
    }, options);
    return await this.getResourceCollection(type, _extends({}, options, {
      locale: context.locale,
      defaultLocale: context.defaultLocale,
      withAuth: this.getAuthFromContextAndOptions(context, options)
    }));
  }

  async getStaticPathsFromContext(types, context, options) {
    var _this = this;

    options = _extends({
      withAuth: this.withAuth,
      pathPrefix: "/",
      params: {}
    }, options);

    if (typeof types === "string") {
      types = [types];
    }

    const paths = await Promise.all(types.map(async function (type) {
      var _options23, _context$locales;

      // Use sparse fieldset to expand max size.
      // Note we don't need status filter here since this runs non-authenticated (by default).
      const params = _extends({
        [`fields[${type}]`]: "path"
      }, (_options23 = options) == null ? void 0 : _options23.params); // Handle localized path aliases


      if (!((_context$locales = context.locales) != null && _context$locales.length)) {
        const resources = await _this.getResourceCollection(type, {
          params,
          withAuth: options.withAuth
        });
        return _this.buildStaticPathsFromResources(resources, {
          pathPrefix: options.pathPrefix
        });
      }

      const paths = await Promise.all(context.locales.map(async function (locale) {
        const resources = await _this.getResourceCollection(type, {
          deserialize: true,
          locale,
          defaultLocale: context.defaultLocale,
          params,
          withAuth: options.withAuth
        });
        return _this.buildStaticPathsFromResources(resources, {
          locale,
          pathPrefix: options.pathPrefix
        });
      }));
      return paths.flat();
    }));
    return paths.flat();
  }

  buildStaticPathsFromResources(resources, options) {
    const paths = resources == null ? void 0 : resources.flatMap(resource => {
      var _resource$path, _resource$path2;

      return (resource == null ? void 0 : (_resource$path = resource.path) == null ? void 0 : _resource$path.alias) === this.frontPage ? "/" : resource == null ? void 0 : (_resource$path2 = resource.path) == null ? void 0 : _resource$path2.alias;
    }).filter(Boolean);
    return paths != null && paths.length ? this.buildStaticPathsParamsFromPaths(paths, options) : [];
  }

  buildStaticPathsParamsFromPaths(paths, options) {
    return paths.flatMap(_path => {
      _path = _path.replace(/^\/|\/$/g, ""); // Remove pathPrefix.

      if (options != null && options.pathPrefix && options.pathPrefix !== "/") {
        // Remove leading slash from pathPrefix.
        const pathPrefix = options.pathPrefix.replace(/^\//, "");
        _path = _path.replace(`${pathPrefix}/`, "");
      }

      const path = {
        params: {
          slug: _path.split("/")
        }
      };

      if (options != null && options.locale) {
        path["locale"] = options.locale;
      }

      return path;
    });
  }

  async translatePath(path, options) {
    options = _extends({
      withAuth: this.withAuth
    }, options);
    const url = this.buildUrl("/router/translate-path", {
      path
    });
    const response = await this.fetch(url.toString(), {
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      // Do not throw errors here.
      // Otherwise next.js will catch error and throw a 500.
      // We want a 404.
      return null;
    }

    const json = await response.json();
    return json;
  }

  async translatePathFromContext(context, options) {
    options = _extends({
      pathPrefix: "/"
    }, options);
    const path = this.getPathFromContext(context, {
      pathPrefix: options.pathPrefix
    });
    return await this.translatePath(path, {
      withAuth: this.getAuthFromContextAndOptions(context, options)
    });
  }

  getPathFromContext(context, options) {
    var _context$params, _options$pathPrefix;

    options = _extends({
      pathPrefix: "/"
    }, options);
    let slug = (_context$params = context.params) == null ? void 0 : _context$params.slug;
    let pathPrefix = ((_options$pathPrefix = options.pathPrefix) == null ? void 0 : _options$pathPrefix.charAt(0)) === "/" ? options.pathPrefix : `/${options.pathPrefix}`; // Handle locale.

    if (context.locale && context.locale !== context.defaultLocale) {
      pathPrefix = `/${context.locale}${pathPrefix}`;
    }

    slug = Array.isArray(slug) ? slug.map(s => encodeURIComponent(s)).join("/") : slug; // Handle front page.

    if (!slug) {
      slug = this.frontPage;
      pathPrefix = pathPrefix.replace(/\/$/, "");
    }

    slug = pathPrefix.slice(-1) !== "/" && slug.charAt(0) !== "/" ? `/${slug}` : slug;
    return `${pathPrefix}${slug}`;
  }

  async getIndex(locale) {
    const url = this.buildUrl(locale ? `/${locale}${this.apiPrefix}` : this.apiPrefix);

    try {
      const response = await this.fetch(url.toString(), {
        // As per https://www.drupal.org/node/2984034 /jsonapi is public.
        withAuth: false
      });
      return await response.json();
    } catch (error) {
      this.throwError(new Error(`Failed to fetch JSON:API index at ${url.toString()} - ${error.message}`));
    }
  }

  async getEntryForResourceType(type, locale) {
    var _index$links;

    if (this.useDefaultResourceTypeEntry) {
      const [id, bundle] = type.split("--");
      return `${this.baseUrl}` + (locale ? `/${locale}${this.apiPrefix}/` : `${this.apiPrefix}/`) + `${id}/${bundle}`;
    }

    const index = await this.getIndex(locale);
    const link = (_index$links = index.links) == null ? void 0 : _index$links[type];

    if (!link) {
      throw new Error(`Resource of type '${type}' not found.`);
    }

    const {
      href
    } = link; // Fix for missing locale in JSON:API index.
    // This fix ensures the locale is included in the resouce link.

    if (locale) {
      const pattern = `^\\/${locale}\\/`;
      const path = href.replace(this.baseUrl, "");

      if (!new RegExp(pattern, "i").test(path)) {
        return `${this.baseUrl}/${locale}${path}`;
      }
    }

    return href;
  }

  async preview(request, response, options) {
    const {
      slug,
      resourceVersion,
      plugin
    } = request.query;

    try {
      // Always clear preview data to handle different scopes.
      response.clearPreviewData(); // Validate the preview url.

      const validateUrl = this.buildUrl("/next/preview-url");
      const result = await this.fetch(validateUrl.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(request.query)
      });

      if (!result.ok) {
        response.statusCode = result.status;
        return response.json(await result.json());
      }

      const validationPayload = await result.json();
      response.setPreviewData(_extends({
        resourceVersion,
        plugin
      }, validationPayload)); // Fix issue with cookie.
      // See https://github.com/vercel/next.js/discussions/32238.
      // See https://github.com/vercel/next.js/blob/d895a50abbc8f91726daa2d7ebc22c58f58aabbb/packages/next/server/api-utils/node.ts#L504.

      if (this.forceIframeSameSiteCookie) {
        const previous = response.getHeader("Set-Cookie");
        previous.forEach((cookie, index) => {
          previous[index] = cookie.replace("SameSite=Lax", "SameSite=None;Secure");
        });
        response.setHeader(`Set-Cookie`, previous);
      } // We can safely redirect to the slug since this has been validated on the server.


      response.writeHead(307, {
        Location: slug
      });
      return response.end();
    } catch (error) {
      return response.status(422).end();
    }
  }

  async getMenu(name, options) {
    var _options24;

    options = _extends({
      withAuth: this.withAuth,
      deserialize: true,
      params: {},
      withCache: false
    }, options);

    if (options.withCache) {
      const cached = await this.cache.get(options.cacheKey);

      if (cached) {
        this._debug(`Returning cached menu items for ${name}`);

        return JSON.parse(cached);
      }
    }

    const localePrefix = (_options24 = options) != null && _options24.locale && options.locale !== options.defaultLocale ? `/${options.locale}` : "";
    const url = this.buildUrl(`${localePrefix}${this.apiPrefix}/menu_items/${name}`, options.params);

    this._debug(`Fetching menu items for ${name}.`);

    this._debug(url.toString());

    const response = await this.fetch(url.toString(), {
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    const data = await response.json();
    const items = options.deserialize ? this.deserialize(data) : data;
    const {
      items: tree
    } = this.buildMenuTree(items);
    const menu = {
      items,
      tree
    };

    if (options.withCache) {
      await this.cache.set(options.cacheKey, JSON.stringify(menu));
    }

    return menu;
  }

  buildMenuTree(links, parent = "") {
    if (!(links != null && links.length)) {
      return {
        items: []
      };
    }

    const children = links.filter(link => (link == null ? void 0 : link.parent) === parent);
    return children.length ? {
      items: children.map(link => _extends({}, link, this.buildMenuTree(links, link.id)))
    } : {};
  }

  async getView(name, options) {
    var _options25;

    options = _extends({
      withAuth: this.withAuth,
      deserialize: true,
      params: {}
    }, options);
    const localePrefix = (_options25 = options) != null && _options25.locale && options.locale !== options.defaultLocale ? `/${options.locale}` : "";
    const [viewId, displayId] = name.split("--");
    const url = this.buildUrl(`${localePrefix}${this.apiPrefix}/views/${viewId}/${displayId}`, options.params);
    const response = await this.fetch(url.toString(), {
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    const data = await response.json();
    const results = options.deserialize ? this.deserialize(data) : data;
    return {
      id: name,
      results,
      meta: data.meta,
      links: data.links
    };
  }

  async getSearchIndex(name, options) {
    var _options26;

    options = _extends({
      withAuth: this.withAuth,
      deserialize: true
    }, options);
    const localePrefix = (_options26 = options) != null && _options26.locale && options.locale !== options.defaultLocale ? `/${options.locale}` : "";
    const url = this.buildUrl(`${localePrefix}${this.apiPrefix}/index/${name}`, options.params);
    const response = await this.fetch(url.toString(), {
      withAuth: options.withAuth
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    const json = await response.json();
    return options.deserialize ? this.deserialize(json) : json;
  }

  async getSearchIndexFromContext(name, context, options) {
    return await this.getSearchIndex(name, _extends({}, options, {
      locale: context.locale,
      defaultLocale: context.defaultLocale
    }));
  }

  buildUrl(path, params) {
    const url = new URL(path.charAt(0) === "/" ? `${this.baseUrl}${path}` : path);

    if (typeof params === "object" && "getQueryObject" in params) {
      params = params.getQueryObject();
    }

    if (params) {
      // Used instead URLSearchParams for nested params.
      url.search = stringify(params);
    }

    return url;
  }

  async getAccessToken(opts) {
    if (this.accessToken && this.accessTokenScope === (opts == null ? void 0 : opts.scope)) {
      return this.accessToken;
    }

    if (!(opts != null && opts.clientId) || !(opts != null && opts.clientSecret)) {
      if (typeof this._auth === "undefined") {
        throw new Error("auth is not configured. See https://next-drupal.org/docs/client/auth");
      }
    }

    if (!isClientIdSecretAuth(this._auth) || opts && !isClientIdSecretAuth(opts)) {
      throw new Error(`'clientId' and 'clientSecret' required. See https://next-drupal.org/docs/client/auth`);
    }

    const clientId = (opts == null ? void 0 : opts.clientId) || this._auth.clientId;
    const clientSecret = (opts == null ? void 0 : opts.clientSecret) || this._auth.clientSecret;
    const url = this.buildUrl((opts == null ? void 0 : opts.url) || this._auth.url || DEFAULT_AUTH_URL);

    if (this.accessTokenScope === (opts == null ? void 0 : opts.scope) && this._token && Date.now() < this.tokenExpiresOn) {
      this._debug(`Using existing access token.`);

      return this._token;
    }

    this._debug(`Fetching new access token.`);

    const basic = Buffer.from(`${clientId}:${clientSecret}`).toString("base64");
    let body = `grant_type=client_credentials`;

    if (opts != null && opts.scope) {
      body = `${body}&scope=${opts.scope}`;

      this._debug(`Using scope: ${opts.scope}`);
    }

    const response = await this.fetch(url.toString(), {
      method: "POST",
      headers: {
        Authorization: `Basic ${basic}`,
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });

    if (!(response != null && response.ok)) {
      await this.handleJsonApiErrors(response);
    }

    const result = await response.json();

    this._debug(result);

    this.token = result;
    this.accessTokenScope = opts == null ? void 0 : opts.scope;
    return result;
  }

  deserialize(body, options) {
    if (!body) return null;
    return this.serializer.deserialize(body, options);
  }

  async getErrorsFromResponse(response) {
    const type = response.headers.get("content-type");

    if (type === "application/json") {
      const error = await response.json();
      return error.message;
    } // Construct error from response.
    // Check for type to ensure this is a JSON:API formatted error.
    // See https://jsonapi.org/format/#errors.


    if (type === "application/vnd.api+json") {
      var _error$errors;

      const _error = await response.json();

      if (_error != null && (_error$errors = _error.errors) != null && _error$errors.length) {
        return _error.errors;
      }
    }

    return response.statusText;
  }

  formatJsonApiErrors(errors) {
    const [error] = errors;
    let message = `${error.status} ${error.title}`;

    if (error.detail) {
      message += `\n${error.detail}`;
    }

    return message;
  }

  _debug(message) {
    !!this.debug && this.logger.debug(message);
  } // Error handling.
  // If throwErrors is enable, we show errors in the Next.js overlay.
  // Otherwise we log the errors even if debugging is turned off.
  // In production, errors are always logged never thrown.


  throwError(error) {
    if (!this.throwJsonApiErrors) {
      return this.logger.error(error);
    }

    throw error;
  }

  async handleJsonApiErrors(response) {
    if (!(response != null && response.ok)) {
      const errors = await this.getErrorsFromResponse(response);
      throw new JsonApiErrors(errors, response.status);
    }
  }

  getAuthFromContextAndOptions(context, options) {
    var _context$previewData;

    // If not in preview or withAuth is provided, use that.
    if (!context.preview) {
      // If we have provided an auth, use that.
      if (typeof (options == null ? void 0 : options.withAuth) !== "undefined") {
        return options.withAuth;
      } // Otherwise we fallback to the global auth.


      return this.withAuth;
    } // If no plugin is provided, return.


    const plugin = (_context$previewData = context.previewData) == null ? void 0 : _context$previewData["plugin"];

    if (!plugin) {
      return null;
    }

    let withAuth = this._auth;

    if (plugin === "simple_oauth") {
      var _context$previewData2;

      // If we are using a client id and secret auth, pass the scope.
      if (isClientIdSecretAuth(withAuth) && (_context$previewData2 = context.previewData) != null && _context$previewData2["scope"]) {
        var _context$previewData3;

        withAuth = _extends({}, withAuth, {
          scope: (_context$previewData3 = context.previewData) == null ? void 0 : _context$previewData3["scope"]
        });
      }
    }

    if (plugin === "jwt") {
      var _context$previewData4;

      const accessToken = (_context$previewData4 = context.previewData) == null ? void 0 : _context$previewData4["access_token"];

      if (accessToken) {
        return `Bearer ${accessToken}`;
      }
    }

    return withAuth;
  }

}

export { DrupalClient, DrupalPreview, JsonApiErrors, PreviewHandler, buildUrl, deserialize, getAccessToken, getJsonApiIndex, getJsonApiPathForResourceType, getMenu, getPathsFromContext, getResource, getResourceByPath, getResourceCollection, getResourceCollectionFromContext, getResourceFromContext, getResourcePreviewUrl, getResourceTypeFromContext, getSearchIndex, getSearchIndexFromContext, getView, syncDrupalPreviewRoutes, translatePath, translatePathFromContext, useMenu };
//# sourceMappingURL=index.modern.js.map
